+++
date = "2016-06-19T02:52:02+03:00"
draft = false
title = " Перехват пользовательских сигналов в Go"

+++

<p>Перевод статьи "<a href="http://blog.mbassem.com/2016/05/15/handling-user-defined-signals-in-go/">Handling User Defined Signals in Go</a>"</p>

<p>Сигналы представляют собой ограниченный способ коммуникации между процессами. Сигналы используют для прерывания выполнения программы и срабатывания определенного обработчика. К примеру, когда вы нажимаете комбинацию клавиш CTRL+C в терминале для остановки запущенной программы, то таким образом вы посылаете сигнал SIGINT. Обычно, при получении сигнала SIGINT процесс убивается, но некоторые процессы могут перехватывать сигнал и игнорировать его или выполнять некоторую подготовительную работу перед выходом. Еще один довольно известный сигнал SIGKILL намного "брутальнее". Как только процесс получает этот сигнал, то сразу же прекращает свою работу и нет никаких способов игнорировать этот сигнал. Существует очень много различных сигналов, их описание можно найти на <a href="https://en.wikipedia.org/wiki/Unix_signal#POSIX_signals">wikipedia</a>.</p>

<p>Посылать сигналы процессу можно с помощью команды <code>kill &lt;signal&gt; &lt;PID&gt;</code>. Тут <code>PID</code> - это идентификатор процесса. К примеру, чтобы завершить определенный процесс, вы можете послать сигнал <code>SIGKILL</code> воспользовавшись командой <code>kill -KILL &lt;PID&gt;</code>. Для удобства можно использовать команду <code>pkill</code> и вместо идентификатора указывать имя процесса.</p>

<p>В этом посте мы будем говорить о специальных пользовательских сигналах <code>USR1</code> и <code>USR2</code>. Оба эти сигнала предоставляются всецело в ваше распоряжение и вы сами можете определить их обработчики. Я покажу несколько популярных способов их использования. Все примеры написанны на языке Go, но основные идеи не зависят от выбранного языка и могут быть реализованны на чем угодно.</p>

<h3>Перехватывание сигналов</h3>

<p>В Go вы можете перехватывать сигналы с использованием функции <code>signal.Notify(chan os.Signal, syscall.Signal)</code>. Эта функция принимает канал и сообщает вам, когда произошел перехвать сигнала. Когда программа получает сигнал, то в канал посылается значение типа <code>os.Signal</code>. Примерно это выглядит так:</p>

<pre><code>func handle(c chan os.Signal) {
    for {
        &lt;-c // This line will block until a signal is received
        // DO SOMETHING
    }
}

func main() {
    c := make(chan os.Signal, 1)
    signal.Notify(c, syscall.SIGUSR1)
    go handle(c)
}
</code></pre>

<p>Теперь мы знаем как перехватывать сигналы и определять наши собственные обработчики.</p>

<h3>Переключатель для режима логирования.</h3>

<p>Давайте представим, что у вас есть веб-приложение, которое, конечно же, пишет логи. Сделать лог очень полным и многословным считается не очень хорошей идеей, потому что файлы логов разрастутся моментально. Именно поэтому придумали различные уровни логирования (INFO, DEBUG, WARN, и т.д.). Вы запускаете свое приложение с указанием уровня, но если вы захотите отдебажить  какую ни будь проблему, то вам нужно будет перезагрузить ваше приложение с указанием другого уровня логирования.</p>

<p>Для простоты представим, что у вас есть только для два уровня логирования(бесшумный и многословный). Код ниже переключает уровни логирования как только процес получает сигнал <code>USR1</code>.</p>

<pre><code>package main

import (
    "fmt"
    "io"
    "io/ioutil"
    "os"
    "os/signal"
    "sync"
    "syscall"
    "time"
)

// Определяем, куда мы будем выводить сообщения
var writeTo io.Writer = ioutil.Discard
var mutex sync.Mutex

func toggleOutput(c chan os.Signal) {
    for {
        // На этой строчке мы заблокируемся пока не получим сигнал
        &lt;-c

        // Как только мы получили сигнал, необходимо сменить наш writer.
        // Если раньше мы писали в stdout, то меняем на ioutil.Discard
        // и, соответствено, наоборот.
        mutex.Lock()
        if writeTo == os.Stdout {
            writeTo = ioutil.Discard
        } else {
            writeTo = os.Stdout
        }
        mutex.Unlock()
    }
}

func main() {

    fmt.Printf("Process PID : %v\n", os.Getpid())

    c := make(chan os.Signal, 1)
    // В канал `c` попадет сообщение как только получим сигнал SIGUSR1.
    signal.Notify(c, syscall.SIGUSR1)
    go toggleOutput(c)

    // Бесконечный цикл, в котором мы просто увеличиваем счетчик.
    counter := 1
    for {
        mutex.Lock()
        fmt.Fprintln(writeTo, counter)
        mutex.Unlock()
        counter++
        time.Sleep(time.Second)
    }
}
</code></pre>

<p>Напомню, что для отправки сигнала нужно выполнить команду:</p>

<pre><code>$ ps -C signals
  PID TTY          TIME CMD
17659 pts/6    00:00:00 signals
$ kill -s USR1 17659
</code></pre>

<p>В этом примере бинарник с программой называется <code>signals</code>.</p>

<p>И <a href="https://asciinema.org/a/45626">как это выглядит в действии</a>.</p>

<h3>Чтение конфигурационных файлов.</h3>

<p>Еще один удобный вариант использования сигналов, это перегрузка конфигурационных файлов без перезапуска приложения. Представим, что у вас есть приложение, которое читает конфигурацию из YAML файла и просто выводит значения конфигурации на экран. Немного модифицировав это приложение, мы можем сменить старую конфигурацию на новую просто отправив необходимый сигнал.</p>

<pre><code>package main

import (
    "fmt"
    "io/ioutil"
    "os"
    "os/signal"
    "sync"
    "syscall"
    "time"

    "gopkg.in/yaml.v2"
)

// Структура для нашего конфига. Есть только одно поле, его и будем выводить.
type config struct {
    Name string
}

// Обертка над конфигом, которая защищает его через mutex
type context struct {
    config
    sync.Mutex
}

// Глобальная переменная контекста
var ctx *context

func (c *context) Config() config {
    c.Lock()
    cnf := c.config
    c.Unlock()
    return cnf
}

// Функция читает конфигурационный файл "config.yml" и возвращает
// указатель на структуру конфигурации.
func readConfig() config {
    content, err := ioutil.ReadFile("config.yml")
    if err != nil {
        fmt.Fprintln(os.Stderr, err)
        os.Exit(1)
    }

    var tmpCnf config
    err = yaml.Unmarshal(content, &amp;tmpCnf)

    if err != nil {
        fmt.Fprintln(os.Stderr, err)
        os.Exit(1)
    }

    return tmpCnf
}

// Это самая интересная часть
func swapConfig(c chan os.Signal) {
    for {
        // На этой строчке мы заблокируемся пока не получим сигнал
        &lt;-c

        // Как только получаем сигнал, читаем конфигурационный
        // файл и переключаем старый конфиг.
        ctx.Lock()
        ctx.config = readConfig()
        ctx.Unlock()
    }
}

func main() {
    fmt.Printf("Process PID : %v\n", os.Getpid())

    ctx = &amp;context{config: readConfig()}

    c := make(chan os.Signal, 1)

    // В канал `c` попадет сообщение как только получим сигнал SIGUSR1.
    signal.Notify(c, syscall.SIGUSR1)
    go swapConfig(c)

    for {
        fmt.Println(ctx.Config().Name)
        time.Sleep(time.Second)
    }
}
</code></pre>

<p>И как все это <a href="https://asciinema.org/a/45625">выглядит в жизни</a>.</p>

<h3>Заключение</h3>

<p>В этом посте я продемонстрировал два примера использования пользовательских сигналов, но вы можете использовать их по своему усмотрению. Если у вас появятся идеи или вопросы, то милости просим в комментарии.</p>
