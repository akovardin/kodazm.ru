+++
date = "2019-11-30T12:58:12+03:00"
draft = true
title = "Алгоритм RSA на Go"
+++

[https://eli.thegreenplace.net/2019/rsa-theory-and-implementation/](https://eli.thegreenplace.net/2019/rsa-theory-and-implementation/)

RSA - популярный метод криптографии с открытым ключом. Ему уже больше 40 лет, он все еще популярен и используется для некоторых задач в новейшем стандарте TLS  1.3. В этом посте описана математика и некоторые практики которые лежат в основе RSA. Все это применим на практике и реализуем генерацию RSA ключей на Go.

## Алгоритм RSA

Красота алгоритма RSA в его простоте. Вам достаточно знакомства с элементарной теорией чисел, чтобы разобраться в сути за пару часов.

 Договоримся, сто в этой статье *M* это сообщение, которое хотим зашифровать. *C -* уже зашифрованный текст. *C* и *M* большие целые числа. В разделе "Практические соображения" описано как можно представить любые данные в виде больших целых чисел.

Алгоритм RSA состоит из трех основных фаз: генерация ключа, шифрование и дешифрование.

### Генерация ключа

Первое что нужно сделать при использовании RSA - сгенерировать приватный и публичный ключи. Это делается в несколько этапов.

**Шаг 1:** Выбираем два случайных больших числа *p* и *q* и вычисляем n=pq. Насколько большими должны быть эти числа? Рекомендуется выбирать размер для *n* не меньше 2048 бит, более 600 десятичных цифр. Предполагается, что сообщение *M* представлено числом меньше чем *n*(в разделе "Практические соображения" рассказывается что делать если сообщение слишком большое).

**Шаг 2:** Выбираем маленькое нечетное число *e*, которое будет относительно простым к [общей функции Эйлера](https://en.wikipedia.org/wiki/Euler%27s_totient_function) \\(\\phi(n)\\), которая рассчитывается по формуле эйлера:
 
$$
\phi(n) =n \prod_{p\mid n} \left(1-\frac{1}{p}\right)
$$

Для \\(n=pq\\) где *p* и *q* простые числа получаем:

$$
\phi(n)=n\frac{p-1}{p}\frac{q-1}{q}=(p-1)(q-1)
$$

На практике рекомендуется выбирать *e* как одно из известных простых чисел, чаще всего это [65537](https://tools.ietf.org/html/rfc2313). Выбор заранее известного числа никак не влияет на безопасность алгоритма, но дает плюсы в производительности [[1](https://eli.thegreenplace.net/2019/rsa-theory-and-implementation/#id7)].

**Шаг 3:** Вычисляем *d* как мультипликативного обратного по модулю *e* от \\(\\phi(n)\\). Лемма 3 [в этой статье](http://eli.thegreenplace.net/2019/the-chinese-remainder-theorem/) гарантирует что *d* существует и будет уникальным(еще там объясняется что такое модуль мультипликативного обратного).

Сейчас у нас есть все для генерации приватного и публичного ключа. Публичный ключ это пара \\([e,n]\\), приватный это пара \\([d,n]\\). На практике, при расшифровке у нас уже есть доступ к *n* (из публичного ключа), поэтому действительно приватным будет только *d*.

### Шифрование и дешифрование

Шифрование и дешифрование выполняются с помощью одной и той же модульной формулы возведения в степень. Меняются только значения *x* и *y*

$$
f(x)=x^y\pmod{n}
$$

Для шифрования входное значение будет *M*, а показатель степени *e*:

$$
Enc(M)=M^e\pmod{n}
$$

Для дешифровки входное значение это закодированный текст *C*, а степень будет *d*:

$$
Dec(C )=C^d\pmod{n}
$$

## Почему это работает?