+++
date = "2015-02-07T06:11:06+03:00"
draft = false
title = "Названия пакетов"

+++

<p>Перевод статьи <a href="http://blog.golang.org/package-names">"Package names"</a> (автор Sameer Ajmani)</p>

<h3>Введение</h3>

<p>Go код организован в пакеты. Внутри пакета можно обращаться к любому идентификатору(имени) определенному в этом пакете, а клиент может обращаться только к экспортируемым типам, функциям, константам и переменным. Такие обращения всегда содержат имя пакета в качестве префикса: <code>foo.Bar</code> ссылается на экспортируемое имя <code>Bar</code> из пакета <code>foo</code>.</p>

<p>Годные имена пакетов делают код лучше. Имя пакета определяет некоторый контекст для содержимого этого пакета и это позволяет клиентам лучше понимать зачем и как можно его использовать. Также, название помогает сопровождать пакет, определяет что входит в обязанности данного пакета, а что нет. Пакеты с хорошими названиями позволяют проще и быстрей находить необходимый код.</p>

<p>В "<a href="https://golang.org/doc/effective_go.html#names">Effective Go</a>" описаны некоторые базовые принципы именования пакетов, типов, функций и переменных. В этой статье мы продолжим разговор и рассмотрим несколько примеров названий для пакетов из стандартной библиотеки. А также, поговорим о плохих именах, и как от них избавляться.</p>

<h3>Названия пакетов</h3>

<p>Хорошие названия должны быть короткими и "чистыми". Они пишутся в нижнем регистре без _подчеркиваний и смешАногоРегистра. Как правило, это просто существительные, такие как:</p>

<ul>
<li><code>time</code> (предоставляет функционал для измерения и отображения времени)</li>
<li><code>list</code> (реализация двусвязного списка)</li>
<li><code>http</code> (предоставляет реализацию HTTP сервера и клиета)</li>
</ul>

<p>Стиль именования, который типичен для других языков не может быть идиоматическим для Go программы. Вот вам два примера названий, которые прекрасно вписываются в другие языки, но при этом ужасны для использования в рамках Go:</p>

<ul>
<li><code>computeServiceClient</code></li>
<li><code>priority_queue</code></li>
</ul>

<p>Go пакет может экспортировать несколько типов и функций. Например, пакет <code>compute</code> может экспортировать тип <code>Client</code> с методами для использования сервиса и функции для разбиения вычислительных задач на несколько клиентов.</p>

<p><em>Сокращайте с умом.</em> Укорачивать названия пакетов стоит только в том случае, если любой программист точно поймет, что имеется ввиду. У многих часто-используемых пакетов имена сокращены:</p>

<ul>
<li><code>strconv</code> string conversion - преобразование строк</li>
<li><code>syscall</code> system call - системные вызовы</li>
<li><code>fmt</code> formatted I/O - форматирование ввода/вывода</li>
</ul>

<p>Если сокращение названия может спровоцировать нечеткое или двоякое понимание обязанностей пакета, то лучше этого не делать.</p>

<p><em>Не отбирайте хорошие названия у пользователей.</em>  Старайтесь не использовать таких названий, которые могут совпадать с названиями в пользовательском коде. Для примера, пакет для работы с буфферизированным вводом/выводом называется <code>bufio</code>, а не <code>buf</code>, потому что <code>buf</code> это хорошее имя для пользовательской переменной.</p>

<h3>Названия внутри пакетов</h3>

<p>Название пакета и названия для его содержимого всегда взаимосвязанно, потому что клиент использует их совместно. Разрабатывая пакет, нужно иногда смотреть на него с позиции клиента.</p>

<p><em>Избегайте дублирования</em>. Так как клиент использует имя пакета в качестве префикса, то нужно чтобы все используемые названия в пакете не дублировали его имя. HTTP сервер, предоставляемый пакетом <code>http</code> называется просто <code>Server</code>, а не <code>HTTPServer</code>. Клиентский код может использовать его как <code>http.Server</code> - такое название не двусмысленное и нет лишних повторений.</p>

<p><em>Упрощайте названия функций.</em> Когда функция из пакета <code>pkg</code> возвращает значение типа <code>pkg.Pkg</code> (или <code>*pkg.Pkg</code>), то в названии функции имя типа может не упоминаться:</p>

<pre><code class="go">start := time.Now()  // start это переменная типа time.Time
t, err := time.Parse(time.Kitchen, "6:06PM")  // t тип time.Time
</code></pre>

<p>Функция с именем <code>New</code> в пакете <code>pkg</code> возвращает значение типа <code>pkg.Pkg</code>. Это стандартная точка входа для клиентского кода:</p>

<pre><code class="go">q := list.New()  // q это переменная типа *list.List
</code></pre>

<p>Когда функция возвращает значение типа <code>pkg.T</code>, где <code>T</code> это не тип <code>Pkg</code>, то название функции должно включать название типа <code>T</code> что бы клиенту было понятно с чем приходится работать. Типичная ситуация, это пакет с несколькими New-что-там функциями:</p>

<pre><code class="go">d, err := time.ParseDuration("10s")  // d переменная типа time.Duration
elapsed := time.Since(start)         // elapsed переменная типа time.Duration
ticker := time.NewTicker(d)          // ticker переменная типа *time.Ticker
timer := time.NewTimer(d)            // timer переменная типа *time.Timer
</code></pre>

<p>Типы в разных пакетах могут иметь одинаковые имена, потому что для клиента они будут разделены по названию пакета. Для примера, в стандартной библиотеке есть пакеты с разными вариациями <code>Reader</code>: <code>jpeg.Reader</code>, <code>bufio.Reader</code> и <code>csv.Reader</code>. Префикс согласуется с <code>Reader</code> и мы получаем хорошее имя для типа.</p>

<p>Если вы не можете придумать такое название для вашего пакета, которое было бы удачным префиксом для содержимого вашего модуля, то это повод задуматься о правильности выделения абстракций. Напишите код, который будет использовать ваш модуль и, если вам с ним неудобно работать, измените структуру модуля. Такой подход позволит вам писать более удобные и легко поддерживаемые модули с понятным интерфейсом.</p>

<h3>Пакеты и пути</h3>

<p>В Go есть как название пакета так и путь к нему. Название указано в исходниках самого пакета, именно его клиентский код использует как префикс для содержимого. Клиент использует путь пакета во время импорта. По соглашению, последний элемент пути соответствует его названию:</p>

<pre><code class="go">import (
    "fmt"                       // пакет fmt
    "os/exec"                   // пакет exec
    "golang.org/x/net/context"  // пакет context
)
</code></pre>

<p>Инструменты сборки сопоставляют пути пакетов с файловой структурой. Go инструменты используют переменную окружения <a href="https://golang.org/doc/code.html#GOPATH">GOPATH</a> для поиска исходников пакета <code>"github.com/user/hello"</code> в директории <code>$GOPATH/src/github.com/user/hello</code>. (Конечно, вы это, скорее всего, знаете. Но нам нужно определиться с терминологией.)</p>

<p><em>Директории.</em> Стандартная библиотека использует директории для группировки связанных протоколов и алгоритмов, например <code>crypto</code>, <code>container</code>, <code>encoding</code> и <code>image</code>. Нет никакой зависимости между пакетами в одной из таких директорий, это просто способ организовать исходные файлы. Любой пакет может импортировать любой другой пакет при условии что не будет цикличного импорта.</p>

<p>Так же как типы в различных пакетах могут иметь одинаковые имена, так и пакеты в различных директориях могут называться одинаково. Например, <a href="runtime/pprof">runtime/pprof</a> предоставляет данные профилирования в формате для инструмента <a href="https://code.google.com/p/gperftools">pprof</a>, а <a href="https://golang.org/pkg/net/http/pprof">net/http/pprof</a> предоставляет HTTP интерфейс для данных профилирования. Клиентский код использует разные пути импорта, так что нет никакой путаницы. Если нам необходимо импортировать больше одного пакета с одинаковыми названиями, то можно [локально переименовать]((https://golang.org/ref/spec#Import_declarations) один или несколько из них. При локальном переименовании необходимо следовать правилам для именования пакетов(нижний регистр, никаких _подчеркиваний и МешанинРегистров).</p>

<h3>Плохие имена для пакетов</h3>

<p>Плохие названия для пакетов делают код более тяжелым для понимания и поддержки. Ниже описаны признаки, по которым можно судить, что название пакета выбрано не очень удачно.</p>

<p><em>Избегайте бессмысленных названий.</em> Пакеты <code>util</code>, <code>common</code> или <code>misc</code> не дают ни какого представления о своем содержимом. Это усложняет жизнь клиентам, использующим пакет, и разработчикам поддерживающим его. Со временем, такие пакеты разрастаются, зависимостей становится все больше и время копиляции увеличивается, особенно для больших программ. И, поскольку такие названия пакетов в значительной степени универсальны, возникает проблема конфликтов с именами в клиентском коде, что заставляет клиентов выдумывать более хитрые имена.</p>

<p><em>Разделяйте обобщенные пакеты.</em> Для этого посмотрите на типы и функции, описанные в пакете, у которых есть общие элементы и выделите их в отдельные пакеты. Для примера, если у вас есть</p>

<pre><code class="go">package util
func NewStringSet(...string) map[string]bool {...}
func SortStringSet(map[string]bool) []string {...}
</code></pre>

<p>то клиентский код выглядит так</p>

<pre><code class="go">set := util.NewStringSet("c", "a", "b")
fmt.Println(util.SortStringSet(set))
</code></pre>

<p>Переместите эти функции из <code>util</code> в новый пакет, с более подходящим именем:</p>

<pre><code class="go">package stringset
func New(...string) map[string]bool {...}
func Sort(map[string]bool) []string {...}
</code></pre>

<p>тогда клиентский код будет выглядеть так</p>

<pre><code class="go">set := stringset.New("c", "a", "b")``
fmt.Println(stringset.Sort(set))
</code></pre>

<p>После таких изменений значительно проще увидеть, как можно улучшить новый пакет:</p>

<pre><code class="go">package stringset
type Set map[string]bool
func New(...string) Set {...}
func (s Set) Sort() []string {...}
</code></pre>

<p>что позволяет писать еще более простой клиентский код:</p>

<pre><code class="go">set := stringset.New("c", "a", "b")
fmt.Println(set.Sort())
</code></pre>

<p>Название пакета это очень важная часть дизайна вашего проекта. Вам стоит поработать над избавлением от бессмысленных названий из вашего кода.</p>

<p><em>Не используйте один пакет для всех ваших API.</em> Многие программисты часто горят желанием собрать все интерфейсы, предоставляемые их кодом, в один пакет с названием <code>api</code>, <code>types</code>, или <code>interfaces</code>, предполагая, что таким образом облегчают доступ к их коду. Это ошибка. Такие пакеты страдают теми же проблемами, что и пакеты с названиями <code>util</code> или <code>common</code>, разрастаются, используют все больше зависимостей и конфликтуют с другими аналогичными пакетами и клиентским кодом. Разделяйте такие пакеты с использованием директорий и с учетом реализации.</p>

<p><em>Избегайте ненужных конфликтов имен.</em> Хотя пакеты в разных директориях могут называться одинаково, совместно используемым пакетам желательно иметь различные имена. Это уменьшает путаницу и необходимость локального переименования. По тем же причинам, стоит избегать использовать названия совпадающие с названиями в стандартной библиотеке, такие как <code>io</code> или <code>http</code>.</p>

<h3>Заключение</h3>

<p>Названия пакетов это основа для хороших имен во всей программе. Стоит потратить время, для выбора подходящих названий и организации кода. В будущем это поможет клиентам быстрее понимать и правильно использовать ваш код. Также, такой подход даст возможность проще и изящней расширять пакет.</p>

<h3>Почитать</h3>

<ul>
<li><a href="https://golang.org/doc/effective_go.html">Эффективный Go</a></li>
<li><a href="https://golang.org/doc/code.html">Как писать Go код</a></li>
<li><a href="https://blog.golang.org/organizing-go-code">Организация Go кода (2012 пост в блоге)</a></li>
<li><a href="https://talks.golang.org/2014/organizeio.slide">Организация Go кода (2014 Google I/O talk)</a></li>
</ul>
