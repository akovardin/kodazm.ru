+++
date = "2018-11-24T20:53:09+03:00"
draft = true
title = "Бесшовное обновление"
+++

Перевод статьи "[Graceful upgrades in Go](https://blog.cloudflare.com/graceful-upgrades-in-go/)"

Идея бесшовного обновления заключается в смене конфигурации и кода процесса пока он запущен, так что никто ничего не заметил. Если вам кажется что этот способ небезопасный, нежелательный и подверженный ошибкам - то я в целом я с вами согласен. Но иногда вам нужна такая функциональность. Такое часто случается если у вас нет балансера перед вашим приложением. Такой подход используется в Cloudflare и нам пришлось реализовать целый набор различных решений вокруг этой проблемы.


![](/img/graceful/thing.jpg)

Оказалось что для решение этой задачи нужно немного низкоуровневого программирования и это реально затягивает. В этой статье вы узнаете на какие компромиссы нам пришлось пойти и почему вам стоит использовать нашу опенсорсную либу. Для нетерпеливых ссылка на [гитхаб](https://github.com/cloudflare/tableflip) и на [документацию](https://godoc.org/github.com/cloudflare/tableflip).

### Основы

Что это вообще такое бесшовное обновление для процесса? К примеру, есть некоторый сферический ыеб-сервер. Мы хотим отправлять к нему запросы и никогда не получать ошибки потому что он умеет бесшовно обновляться. 

Мы знаем, что HTTP использует TCP под капотом, а с TCP мы взаимодействуем через BSD сокеты. Мы говорим OS что хотим принимать соединения на 80 порт и OS предоставляет нам сокет на прослушивание, затем мы вызываем `Accept()` и ожидаем новых клиентов.

Мы не сможем обслужить клиентов если OS не будет знать о прослушивании 80 порта или не будет вызван `Accept()`. Весь фокус в бесшовном обновление - не допускать этих двух моментов, те всегда прослушивать 80 порт и вызывать `Accept()`. Давайте рассмотрим как можно добиться такого поведения. Начнем с простых решений и будем двигаться к сложным.

### Простой `Exec()`

Окей, посмотрим насколько все это сложно. Для начала будем использовать `Exec()` с новым бинарником(для начала без форка). Это делает именно то что нужно - заменяет текущий код новым, загруженным с диска.

```go
// The following is pseudo-Go.

func main() {
	var ln net.Listener
	if isUpgrade {
		ln = net.FileListener(os.NewFile(uintptr(fdNumber), "listener"))
	} else {
		ln = net.Listen(network, address)
	}
	
	go handleRequests(ln)

	<-waitForUpgradeRequest

	syscall.Exec(os.Argv[0], os.Argv[1:], os.Environ())
}
```

К сожалению, такой подход имеет ряд фатальных недостатков. Мы не можем отменить `Exec()`. Например, если у вас есть ошибка в конфиге, то новый процесс попытается прочитать его и просто упадет.

Кроме того, такое решение предполагает, что новый процесс инициализируется мгновенно. На самом деле между загрузкой нового бинарника и первым вызовом `Accept()` может пройти много времени и ядро отменит часть соединений, так как [очередь прослушивания будет переполненной](https://veithen.github.io/2014/01/01/how-tcp-backlog-works-in-linux.html).

![](/img/graceful/Example1-1.png)

Использование чистого `Exec()` не наш путь.

### Listen() все на свете

Теперь мы можем попробовать более продвинутое решение. Давайте форкнем и запустим новый процесс, который проинициализируется как обычно. В какой-то момент будут созданы сокеты, прослушивающие одинаковые адреса. К сожалению, так это не заработает - мы получим ошибку 48 известную как "Address Already In Use". Ядро запрещает нам прослушивание на тому же адресу и порту, которые использовались для старого процесса.

Но у нас есть флаг `SO_REUSEPORT`. С его помощью можно сказать ядру, чтоб оно игнорировало факт прослушивания сокета по адресу с портом и просто алоцировало новый.

```go
func main() {
	ln := net.ListenWithReusePort(network, address)

	go handleRequests(ln)

	<-waitForUpgradeRequest

	cmd := exec.Command(os.Argv[0], os.Argv[1:])
	cmd.Start()

	<-waitForNewProcess
}
```

Теперь оба процесса прослушивают сокеты и обновление должно заработать. Так?