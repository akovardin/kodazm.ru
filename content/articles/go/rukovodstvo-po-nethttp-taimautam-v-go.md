+++
date = "2016-07-18T22:10:10+03:00"
draft = false
title = "Руководство по net/http таймаутам в Go."

+++

<p>Перевод статьи "<a href="https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts/">The complete guide to Go net/http timeouts</a>".</p>

<p>Когда вы пишите веб-приложение на Go, то таймауты это одно из самых тонких мест, где чаще всего возникают неожиданные ошибки. Есть много различных неочевидных моментов, где используются таймауты. И самое гадкое, что ошибка не проявит себя, пока у вас не начнутся проблемы с сетью.</p>

<p>HTTP представляет собой комплексный мультиступенчатый протокол, в котором нет возможности указать единый таймаут, одинаковый для всех случаев. Мы можем его использовать для стриминга, JSON API или <a href="https://en.wikipedia.org/wiki/Comet_">Comet</a>. И конечно же, неразумно использовать одинаковые параметры по умолчанию для всех случаев.</p>

<p>В этой статье мы поговорим о различных вариантах использования таймаутов в Go приложениях и как это делать правильно. Рассмотрим таймауты как на стороне клиента, так и на стороне сервера.</p>

<h3>SetDeadline</h3>

<p>Прежде всего, необходимо познакомится с сетевыми примитивами в которых используются Deadlines(дедлайн, предельные сроки).</p>

<p>Дедлайн - это предельный абсолютный срок за который должны завершиться все операции ввода/вывода, иначе в системе возникнет ошибка таймаута. Этот крайний срок можно установить с помощью метода <code>Set[Read|Write]Deadline(time.Time)</code> у <code>net.Conn</code>.</p>

<p>Важно понимать, что <em>дедлайн это не таймаут</em>. Как только вы его установили, то они остаются в неизменном виде на все время работы программы(или до следующего вызова <code>SetDeadline</code>), не зависимо от того, как соединение используется в данный момент. Получается, единственный способ настроить дедлайн, это вызывать <code>SetDeadline</code> перед каждым вызовом операций <code>Read</code>/<code>Write</code>.</p>

<p>Вероятно, вы не очень хотите вызывать <code>SetDeadline</code> вручную и были бы не против, если <code>net/http</code> будет делать это за вас через использование более высокоуровневых таймаутов. Однако, нужно помнить, что все таймауты реализуются на базе дедлайнов, а это означает, что <em>нет необходимости переустанавливать их</em> в момент отправки или получения данных.</p>

<h3>Серверные таймауты</h3>

<p><img src="https://blog.cloudflare.com/content/images/2016/06/Timeouts-001.png" alt="" /></p>

<p>Для любого сервера в интернете очень важно иметь таймауты для клиентских подключений. Иначе, при наличии медленных клиентов, очень легко может возникнуть утечка рессурсов(в частности, файловых дескрипторов), что в конечном счете приведет к чему-то такому:</p>

<pre><code>http: Accept error: accept tcp [::]:80: accept4: too many open files; retrying in 5ms
</code></pre>

<p>Но у наст есть два таймаута в <code>http.Server</code>: <code>ReadTimeout</code> и <code>WriteTimeout</code>. Вы можете указать их при инициализации сервера:</p>

<pre><code>srv := &amp;http.Server{  
    ReadTimeout: 5 * time.Second,
    WriteTimeout: 10 * time.Second,
}
log.Println(srv.ListenAndServe())  
</code></pre>

<p><code>ReadTimeout</code> покрывает время с момента принятия соединения до момента, когда тело запроса будет полностью прочитано(если вы не читаете тело запроса, то до момента прочтения заголовков). Этот механизм реализован в <code>net/http</code> через вызов <code>SetReadDeadline</code> <a href="https://github.com/golang/go/blob/3ba31558d1bca8ae6d2f03209b4cae55381175b3/src/net/http/server.go#L750">сразу же после <code>Accept</code></a>.</p>

<p><code>WriteTimeout</code> покрывает время от завершения чтения заголовков запроса до конца записи ответа(время работы <code>ServeHTTP</code>) и реализован через вызов <code>SetWriteDeadline</code> в <a href="https://github.com/golang/go/blob/3ba31558d1bca8ae6d2f03209b4cae55381175b3/src/net/http/server.go#L753-L755">конце вызова readRequest</a>.</p>

<p>Кроме того, когда соединение работает по HTTPS, <code>SetWriteDeadline</code> вызывается <a href="https://github.com/golang/go/blob/3ba31558d1bca8ae6d2f03209b4cae55381175b3/src/net/http/server.go#L1477-L1483">сразу же после Accept</a>. Это справедливо для всех пакетов, записанных как часть TLS рукопожатия. Досадно, но это означает, что в таком случае <code>WriteTimeout</code> учитывает время от начала чтения заголовков и ожидание записи первого байта.</p>

<p>Вы обязательно должны выставлять таймауты когда работаете с ненадежными клиентами и/или в нестабильной сети, так как клиенты могут заблокировать соединение своим медленным чтением или записью.</p>

<p>Стоит упомянуть <code>http.TimeoutHandler</code>. Это не параметр сервера. Это такой себе <code>Handler</code> врапер, который может ограничить максимальное время выполнения <code>ServeHTTP</code>. Происходит буферизация ответа, а в случае истечения дедлайна, клиенту посылается 504 Gateway Timeout. Нужно помнить, что это <a href="https://github.com/golang/go/issues/15327">сломали в 1.6 и пофиксили в 1.6.2</a>.</p>

<h4>http.ListenAndServe делает это не правильно</h4>

<p>Все выше перечисленное означает, что удобные обертки над <code>http.Server</code>, такие как <code>http.ListenAndServe</code>, <code>http.ListenAndServeTLS</code> и <code>http.Serve</code> во многих ситуациях не самый хороший выбор.</p>

<p>Все эти функции оставляют настройки таймаутов по умолчанию выключенными и не дают возможности их настроить. Поэтому, если вы их используете, то рано или поздно столкнетесь с утечкой соединений и дескрипторов. Я совершил эту ошибку более дюжины раз.</p>

<p>Лучше всего, всегда используйте <code>http.Server</code> и всегда устанавливайте <code>ReadTimeout</code> и <code>WriteTimeout</code>. Можно написать свои аналогичные методы, которые будут использовать таймауты.</p>

<h4>О стриминге</h4>

<p>К сожалению, нет никакого способа добраться к <code>net.Conn</code> из <code>ServeHTTP</code>. Поэтому, сервер который планирует использовать стриминг, должен изначально запускаться с выключенными таймаутами(возможно, именно поэтому таймауты по умолчанию выключены). Без возможности добраться до <code>net.Conn</code> нет никакого способа вызвать <code>SetWriteDeadline</code> перед каждой записью <code>Write</code>, если мы хотим реализовать разовый(не абсолютный) таймаут.</p>

<p>Так же, нет никаких способов отменить заблокировать <code>ResponseWriter.Write</code> так как <code>ResponseWriter.Close</code> (до которого можно добраться через интерфейс) не может разблокировать конкурентную запись, по крайней мере, это не описано в документации. Это означает, что у нас нет способа реализовать таймауты в ручную с помощью <code>Timer</code>, например.</p>

<p>Выходит, что стриминговые серверы не могут защититься от медленных клиентов.</p>

<p>Я отправил <a href="https://github.com/golang/go/issues/16100">предложение по этому поводу</a>) и буду рад вашей поддержке и отзывам.</p>

<h3>Клиентские таймауты</h3>

<p><img src="https://blog.cloudflare.com/content/images/2016/06/Timeouts-002.png" alt="" /></p>

<p>Настройка таймаутов на клиенте может быть как проще, так и намного сложнее чем на сервере. Тем не менее, клиентские таймауты очень важны и точно также могут влиять на утечку ресурсов.</p>

<p>Самый простой способ - использовать поле <code>Timeout</code> у структуры <code>http.Client</code>. Этот таймаут покрывает все время выполнения запроса, от вызова <code>Dial</code>(если соединение не переиспользуется) до прочтения тела запроса.</p>

<pre><code>c := &amp;http.Client{  
    Timeout: 15 * time.Second,
}
resp, err := c.Get("https://blog.filippo.io/")  
</code></pre>

<p>Так же как и при создании сервера, функции из пакета, такие как <code>http.Get</code>, используют <code>Client</code> <a href="https://golang.org/pkg/net/http/#DefaultClient">без указания таймаутов</a>. А мы уже знаем, что такое использование может привести к проблемам.</p>

<p>Для более точного контроля, существует целый набор таймаутов, которые вы можете использовать:</p>

<ul>
<li><code>net.Dialer.Timeout</code> ограничивает время на установление TCP соединения(если нужно открывать новое соединение).</li>
<li><code>http.Transport.TLSHandshakeTimeout</code> ограничивает время на выполнене TLS рукопожатия.</li>
<li><code>http.Transport.ResponseHeaderTimeout</code> ограничивает время на чтения заголовков ответа.</li>
<li><code>http.Transport.ExpectContinueTimeout</code> ограничивает время ожидания клиентом между отправкой заголовка <code>Expect: 100-continue</code> и получением подтверждения для отправки тела сообщения. Замечу, что при использовании этой настройки а 1.6 будет <a href="https://github.com/golang/go/issues/14391">отключен HTTP/2</a>. (в случае с <code>DefaultTransport</code> это <a href="https://github.com/golang/go/commit/406752b640fcc56a9287b8454564cffe2f0021c1#diff-6951e7593bfb1e773c9121df44df1c36R179">специальный кейс 1.6.2</a>).</li>
</ul>

<pre><code>c := &amp;http.Client{  
    Transport: &amp;Transport{
        Dial: (&amp;net.Dialer{
                Timeout:   30 * time.Second,
                KeepAlive: 30 * time.Second,
        }).Dial,
        TLSHandshakeTimeout:   10 * time.Second,
        ResponseHeaderTimeout: 10 * time.Second,
        ExpectContinueTimeout: 1 * time.Second,
    }
}
</code></pre>

<p>Нет никакого способа по умолчанию ограничить время, потраченное на обработку конкретного запроса. Время на чтение тела запроса можно контролировать вручную с помощью <code>time.Timer</code>, так как это происходит уже после вызова метода из структуры <code>Client</code>(ниже я расскажу, как отменять запросы).</p>

<p>В Go 1.7 появился новый параметр <code>http.Transport.IdleConnTimeout</code>. С его помощью не получится контролировать заблокированные запросы, но можно указать как долго заблокированные соединения должны находится в пуле.</p>

<p>Нужно помнить, что по умолчанию <code>Client</code> следует по всем редиректам. <code>http.Client.Timeout</code> это общее время, независимо от того, сколько редиректоа произошло. А все все таймауты настроенные в <code>http.Transport</code> отвечают за каждый запрос, так как это более низкоуровневый элемент, не учитывающий редиректы.</p>

<h3>Отмена и контекст</h3>

<p><code>net/http</code> предоставляет два способа для отмены контекста: <code>Request.Cancel</code> и <code>Context</code>(нововведение в 1.7).</p>

<p><code>Request.Cancel</code> это специальный канал, при закрытии которого происходит отмена запроса, аналогично как это происходит при срабатывании <code>Request.Timeout</code>. И в том и в другом случае используется похожий механизм. Пока я писал эту статью, я нашел баг в 1.7, при котором в момент отмены запроса возникает ошибка таймаута.</p>

<p>Мы можем использовать <code>Request.Cancel</code> и <code>time.Timer</code> для еще более тонкого управления таймаутами, которые позволяют стримить, и переустанавливать дедлайны как только мы смогли прочитать часть данных:</p>

<pre><code>package main

import (  
    "io"
    "io/ioutil"
    "log"
    "net/http"
    "time"
)

func main() {  
    c := make(chan struct{})
    timer := time.AfterFunc(5*time.Second, func() {
        close(c)
    })

    // Выдаем 256 байтов каждую секунду.
    req, err := http.NewRequest("GET", "http://httpbin.org/range/2048?duration=8&amp;chunk_size=256", nil)
    if err != nil {
        log.Fatal(err)
    }
    req.Cancel = c

    log.Println("Sending request...")
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        log.Fatal(err)
    }
    defer resp.Body.Close()

    log.Println("Reading body...")
    for {
        // Можно поменять на: timer.Reset(50 * time.Millisecond)
        timer.Reset(2 * time.Second)
        _, err = io.CopyN(ioutil.Discard, resp.Body, 256)
        if err == io.EOF {
            break
        } else if err != nil {
            log.Fatal(err)
        }
    }
}
</code></pre>

<p>В примере выше мы выделяем 5 секунд на <code>Do</code> фазу запроса, затем мы потратим 8 секунд на чтение тела запроса в 8 этапов, каждый из которых длится не больше 2 секунд. Мы могли бы работать с потоком в таком режиме, без боязни "залипнуть". Если за 2 секунды мы не смогли получить данные из тела запроса, то io.CopyN должен вернуть <code>net/http: request canceled</code>.</p>

<p>В 1.7 в стандартную библиотеку добавился пакет <code>context</code>. Конечно, это намного более <a href="https://blog.golang.org/context">функциональный инструмент</a>, но мы воспользуемся только той частью, которая может заменить <code>Request.Cancel</code>.</p>

<p>Для использования контекста, нам достаточно просто создать новый экземпляр с помощью <code>context.WithCancel</code>, а затем создать <code>Request</code>, привязав к нему наш контекст через <code>Request.WithContext</code>. Когда нам нужно будет отменить запрос, достаточно просто вызвать <code>cancel()</code>(вместо закрытия канала <code>Cancel</code> в <code>Request</code>):</p>

<pre><code>ctx, cancel := context.WithCancel(context.TODO())  
timer := time.AfterFunc(5*time.Second, func() {  
    cancel()
})

req, err := http.NewRequest("GET", "http://httpbin.org/range/2048?duration=8&amp;chunk_size=256", nil)  
if err != nil {  
    log.Fatal(err)
}
req = req.WithContext(ctx)  
</code></pre>

<p>У контекстов есть одно преимущество: если родительский контекст(который мы указали в <code>context.WithCancel</code>) выполняет отмену, то наши контексты делают тоже самое. Таким образом, команда отмены распространяется по всему конвейеру.</p>

<p>На этом все. Надеюсь, я не превысил ваш <code>ReadDeadline</code>!</p>

<p>Если вам понравилось это погружение в стандартную библиотеку Go, то приходите к <a href="https://www.cloudflare.com/join-our-team/">нам на работу в Лондон, Остин (TX), Шампейн (IL), Сан-Франциско и Сингапур</a>..</p>
