+++
date = "2016-03-03T12:43:12+03:00"
draft = false
title = "Осторожно, ловушка"

+++

<h3>Проблема</h3>

<p>Go замечательный, простой и понятный язык. Почти все места и конструкции прозрачны как воды Байкала. Даже указатели не пугают, в отличии от C/C++. Но есть парочка мест, которые не так очевидны, как ожидалось.</p>

<p>Один из таких непонятных моментов - это использование наборов методов для указателей и неуказателей в связке с интерфейсами. Сначала я опишу саму проблему, а потом приведу перевод документации про наборы методов(method sets), чтобы было понятно откуда ноги растут.</p>

<p>И так, начнем с простого примера. У нас есть некоторый интерфейс:</p>

<pre><code>type phoner interface {
    call()
}
</code></pre>

<p>И мы хотим реализовать этот интерфейс. Для этого создадим свой тип на базе структуры:</p>

<pre><code>type phone struct {
}

func (p *phone) call() {
    fmt.Println("call")
}
</code></pre>

<p>Тут видно, что приемник у метода <code>call</code> это переменная типа <code>*phone</code>, то есть это указатель.</p>

<p>Так как <code>phone</code> реализовывает интерфейс <code>phoner</code>, то теперь мы можем использовать интерфейс как тип для наших переменных:</p>

<pre><code>var p phoner = &amp;phone{}
p.call()
</code></pre>

<p>В этом коде нет ничего подозрительного. Метод <code>call</code> использует приемник с типом указателя, а в переменную <code>p</code> мы именно указатель и записываем.</p>

<p>Что будет, если мы вместо <code>&amp;phone{}</code> будем использовать просто <code>phone{}</code>?</p>

<pre><code>var p phoner = phone{}
p.call()
</code></pre>

<p>В таком случае, ваша программа даже не соберется, потому что типы не совпадают. Интерфейс <code>phoner</code> реализован для типа <code>*phone</code>, но не для типа <code>phone</code>. Что, в принципе, понятно: указатель на значение и само значение это два совершенно разных типа.</p>

<p>Хорошо, давайте теперь реализуем интерфейс не для указателя, а для значения:</p>

<pre><code>type phone struct {
}

func (p phone) call() {
    fmt.Println("call")
}
</code></pre>

<p>И будем его использовать</p>

<pre><code>var p phoner = phone{}
p.call()
</code></pre>

<p>И тут мы подкрались с самому непонятному месту. Вот так тоже работает:</p>

<pre><code>var p phoner = &amp;phone{}
p.call()
</code></pre>

<p>А чтобы разобраться почему все именно так, нужно чуть более внимательно почитать документацию.</p>

<h3>Наборы методов(Method Sets)</h3>

<p>Далее я перевел небольшой <a href="https://github.com/golang/go/wiki/MethodSets">отрывок документации</a>, в котором описаны наборы методов и правила их использования.</p>

<h4>Спецификация</h4>

<p>Наборы методов для определенного типа имеют важное значение в Go. Набор методов определяет, какой интерфейс можно использовать для значения определенного типа.</p>

<p>В спецификации по языку есть два важных момента, описывающих наборы методов:</p>

<p><em>Наборы методов</em>: Тип может иметь ассоциированные методы. Набор методов интерфейсного типа это и есть его интерфейс. Набор методов любого другого именного типа <code>type T</code> состоит из всех методов с указанием приемника типа <code>T</code>. Набор методов для типа <code>type *T</code> это набор всех методов с приемником типа <code>*T</code> и/или <code>T</code>(то есть, он включает набор методов <code>T</code>). Любой другой тип имеет пустой набор методов. В рамках одного набора методы должны иметь уникальное название.</p>

<p><em>Вызовы</em>: Вызов метода <code>x.m()</code> является валидным если набор методов типа <code>x</code> содержит <code>m</code> и список аргументов соответствует списку параметров метода <code>m</code>. Если <code>x</code> адресуемая переменная и набор методов для <code>&amp;x</code> содержит <code>m</code>, то мы можем вызвать метод как <code>x.m()</code>, что, по сути, является сокращением для <code>(&amp;x).m()</code>.</p>

<h4>Использование</h4>

<p>Наверняка, вы будете использовать наборы методов ежедневно. Вы можете использовать методы при работе с переменными, элементами слайса, элементами map и интерфейсами.</p>

<h3>Переменные</h3>

<p>Если у вас есть переменная определенного типа, который ассоциирован с набором методов, то вы можете вызывать практически любые методы. Если учитывать правила, описанные в спецификации, то можно написать такой код:</p>

<pre><code class="go">type List []int

func (l List) Len() int        { return len(l) }
func (l *List) Append(val int) { *l = append(*l, val) }

func main() {
    // A bare value
    var lst List
    lst.Append(1)
    fmt.Printf("%v (len: %d)\n", lst, lst.Len())

    // A pointer value
    plst := new(List)
    plst.Append(2)
    fmt.Printf("%v (len: %d)\n", plst, plst.Len())
}
</code></pre>

<p>Обратите внимание, что мы вызываем оба метода(и с приемником указателем, и с приемником значением) как для указателя, так и для значения. Чтобы лучше разобраться как это работает, давайте составим табличку методов:</p>

<pre><code class="go">List
- Len() int

*List
- Len() int
- Append(int) 
</code></pre>

<p>Тут видно, что в наборе методов для типа <code>List</code> не содержится метод <code>Append(int)</code>, тем не менее, вы можете его вызвать и программа будет работать корректно. Это объясняется вторым правилом из спецификации и неявным преобразованием вида:</p>

<pre><code class="go">lst.Append(1)
(&amp;lst).Append(1)
</code></pre>

<p>В таком случае, у выражения <code>(&amp;lst)</code> будет тип <code>*List</code> который позволит вызвать метод <code>Append(int)</code>. Чтобы лучше запомнить эти правила, стоит рассмотреть методы, использующие указатель или значение как приемник, отдельно от набора методов. Любой метод, в котором приемник это указатель, можно вызывать относительно любого указателя, или значения, указатель на которое мы можем получить(как это происходить в примере выше). Любой метод, в котором приемник это значение, может быть вызван для значения или для указателя, если его можно разименовать(то есть, для любого указателя).</p>

<h4>Элементы слайса</h4>

<p>Тут все как и с переменными. Так как элементы слайса это, по сути, указатели, то тип приемника не важен. Можно вызывать все методы, в которых приемник это указатель, или значение.</p>

<h3>Элементы map</h3>

<p>Элементы map не адресуемые. Таким образом, код ниже не заработает:</p>

<pre><code class="go">lists := map[string]List{}
lists["primes"].Append(7) 
// не может быть переписано как (&amp;lists["primes"]).Append(7)
</code></pre>

<p>Но если мы сами будем использовать указатели, то все будет хорошо работать:</p>

<pre><code class="go">lists := map[string]*List{}
lists["primes"] = new(List)
lists["primes"].Append(7)
count := lists["primes"].Len() 
// может быть переписано как (*lists["primes"]).Len()
</code></pre>

<p>Таким образом, если элемент map это указатель, то могут быть вызваны оба типа методов. А если элемент map простое значение, то могут быть вызваны только методы, у которых приемник значение.</p>

<h4>Интерфейсы</h4>

<p>Конкретное значение, которое хранится в переменной с типом интерфейса, всегда неадресуемое, аналогично элементу map. Таким образом, когда вы вызываете метод у переменной с интерфейсным типом, то этот метод должен иметь соответствующий тип приемника или значение в переменной должно быть получено из соответствующего типа: для методов с приемником указателем это должен быть указатель, для методов с приемником значением это должно быть значение. При этом, методы с приемниками указателями могут вызываться для переменных интерфейсного типа, если их значения указатель, так как этот указатель можно разименовать. Но методы с приемниками значениями нельзя вызвать, так как значения, сохраненные внутри интерфейсной переменной, не адресуемые. При приведении типа к интерфейсу компилятор следит за тем, чтобы все методы, объявленные в интерфейсе, можно было вызвать и если это не так, то сообщает о ошибке компиляции. Расширим предыдущий пример и покажем валидные и невалидные использования интерфейсов:</p>

<pre><code class="go">type List []int

func (l List) Len() int        { return len(l) }
func (l *List) Append(val int) { *l = append(*l, val) }

type Appender interface {
    Append(int)
}

func CountInto(a Appender, start, end int) {
    for i := start; i &lt;= end; i++ {
        a.Append(i)
    }
}

type Lener interface {
    Len() int
}

func LongEnough(l Lener) bool {
    return l.Len()*10 &gt; 42
}

func main() {
    // Просто значение
    var lst List
    CountInto(lst, 1, 10) // Невалидно: Append ожидает указатель в приемнике
    if LongEnough(lst) {  // Валидно: oдинаковые типы
        fmt.Printf(" - lst is long enough")
    }

    // Указатель на значение
    plst := new(List)
    CountInto(plst, 1, 10) // Валидно: одинаковые типы
    if LongEnough(plst) {  // Валидно: *List можно разименовать
        fmt.Printf(" - plst is long enough")
    }
}
</code></pre>
