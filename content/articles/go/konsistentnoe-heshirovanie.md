+++
date = "2015-05-02T03:56:03+03:00"
draft = false
title = "Консистентное хеширование"

+++

<p>Перевод статьи "<a href="https://medium.com/sent0hil/consistent-hashing-a-guide-go-implementation-fe3421ac3e8f">Consistent hashing, a guide &amp; Go library</a>".</p>

<p>Понятие и сам метод консистентного хеширования выглядит достаточно простым и мощным, но я все никак не мог с ним разобраться, пока мне не пришлось погрузиться в эту тему с головой. Для начала, стоит определить какие проблемы могут быть решены при его использовании:</p>

<p><img src="https://dl.dropboxusercontent.com/u/750049/4gophers.com/1-AHzeEycsTXnNAkgojeixxA.png" alt="" /></p>

<p>Как определить какой из серверов использовать для хранения и извлечения ключей в распределенной системе? При условии, что все ноды получают примерно одинаковое количество ключей и при добавлении и удалении нод необходимо перемещать минимальное количество ключей.</p>

<p>Давайте предположим, что у нас есть четыре сервера: Chico, Harpo, Groucho и Zeppo. Эти серверы идентичны и ничего не знают друг о друге.</p>

<p><img src="https://dl.dropboxusercontent.com/u/750049/4gophers.com/1-JSsWI9-0SS35tKX6GjmaDg.png" alt="" /></p>

<p>Для простоты, будем считать, что ключи представляют собой простой инкремент. Обычно, вы можете получить некоторое число по ключу и проверочной сумме. И затем можете взять модуль по количеству нод(в нашем случае mod4) для этого числа. Пример проиллюстрирован в табличке на рисунке. На удивление, это работает когда сеть достаточно стабильна и ноды не добавляются/пропадают.</p>

<p><img src="https://dl.dropboxusercontent.com/u/750049/4gophers.com/1-N4YbqC5MslJEJHnv6B0nHQ.png" alt="" /></p>

<p>Но что делать, если одна из нод, например Harpo, отвалится и вообще будет предрасположена к отключениям? У нас будет куча проблем. Используя ту же хеш-функцию, у нас будет похожий результат, но затем нам придется использовать взятие по модулю для трех нод, и результат будет совсем другой.</p>

<p>В этом случае придется перераспределить почти все ключи для всех нод. Но в этом нет никакого смысла, зачем менять кючи для серверов, которые прекрасно работают? Это лишняя работа, которая не дает профита. Теперь понятна причина, по которой стоит использовать консистентное хеширование.</p>

<blockquote>
  <p><strong>Консистентное хеширование</strong> - способ создания распределенных хеш-
  таблиц, при котором вывод из строя одного или более серверов-хранилищ не приводит к необходимости полного переразмещения всех хранимых ключей и значений 
  Взято отсюда: <a href="https://en.wikipedia.org/wiki/Consistent_hashing">https://en.wikipedia.org/wiki/Consistent_hashing</a></p>
</blockquote>

<p>Если мы будем использовать консистентное хеширование, то перераспределять нужно будет только те ключи, которые использовались сервером Harpo. Как правило, в большинстве статей, объясняющих такой тип хеширования, присутствует картинка с единичной окружностью и все объяснение ведется в соответствующих терминах. Давайте не будем отходить от традиции:</p>

<p><img src="https://dl.dropboxusercontent.com/u/750049/4gophers.com/1-x2v-b_Bnpl7DYuGAciX-Iw.png" alt="" /></p>

<p>Временно, не будем обращать внимание как ноды расположены на единичной окружности. Давайте разместим ключи на той же окружности, как будто мы применили взятие по модулю для них (я понимаю, что пока это выглядит как размахивание руками, но я скоро вернусь к реализации). Для определения какие ключи к какой ноде относятся, просто будем перемещаться по часовой стрелке. Таким образом, ключ 1, например, относится к ноде Harpo.</p>

<p>В таком случае, что произойдет если упадет нода Harpo? Тогда вам придется работать с ключем 1 на другой ноде, которая будет по часовой стрелке за Harpo, но нет нужды перераспределять все ключи. Вуаля! Так же, это прекрасно работает с добавлением новых нод. Скажем, вы добавили сервер Gummo в вашу сеть. Вам все равно не нужно перераспределять ключи, мы сразу узнаем, какие из них теперь будут работать с новой нодой.</p>

<p>Консистентное хеширование прекрасно работает, если ваши ноды могут работать с различным количеством ключей(ноды разной "емкости"). В зависимости от хеш-функции, вы можете разместить "виртуальные" ноды по единичной окружности в случайном порядке. Для нод с большей "емкостью" нам нужно добавить больше "виртуальных" нод. Таким образом, в случае выхода из строя одного узла, ключи не просто переходят на следующую ноду, а равномерно распределяются по нескольким следующим нодам.</p>

<h3>Реализация</h3>

<p>Мы разобрались с теорией и теперь готовы перейти к практической части. Давайте реализуем библиотеку для консистентного хеширования. Мне было проблематично сделать это, пока я не нашел хорошую реализацию, поигрался с кодом, расставил логирование в разных местах. Наша реализация будет в значительной степени схожа с реализацией от <a href="https://github.com/stathat/consistent">stathat</a>. Согласно оригинальному описанию алгоритма, необходимо использовать деревья, но мне больше нравится как это реализованно у stathat.</p>

<p>Давайте начнем с общего описания:</p>

<pre><code class="go">// Инициализация новой распределенной сеть из нод (готовим кольцо).
func NewRing() *Ring
// Добавление ноды в наше кольцо.
func (r *Ring) AddNode(id string)
// Удаление существующей ноды из кольца, если ноды нет,
// то возвращаем ErrNodeNotFound.
func (r *Ring) RemoveNode(id string) error
// Получение ноды, которая работает с указанным ключем. Возвращаемое
// значение это идентификатор ноды, который возвращает ф-ция `AddNode`.
func (r *Ring) Get(key string) string
</code></pre>

<p>Мы будем использовать алгоритм <a href="https://golang.org/pkg/hash/crc32/"><code>crc32</code></a> для генерации проверочной суммы наших ключей. К сожалению, объяснение что такое crc32 и как этот алгоритм работает выходят за рамки этой статьи. Просто знайте, что при любом входящем значении на выходе получится 32 битный юнит. В этом случае, на вход подается ip адрес ноды.</p>

<p>Суть в том, что мы будем хранить полученные проверочные суммы в массиве. Для каждого ключа также будем получать проверочную сумму и по ее значению определять местоположение этого ключа, точнее, с какая нода должна с ним работать. Если это значение будет выходить за рамки массива с нодами, то по умолчанию будет использоваться первая нода.</p>

<p>Для начала определим наше кольцо <code>Ring</code>, в котором будут собраны ноды <code>Node</code></p>

<pre><code class="go">package consistenthash
// Ring это сеть из распределенных нод.
type Ring struct {
  Nodes Nodes
}

// Nodes массив с нодаси.
type Nodes []Node
// Node определение одной ноды.
type Node struct {
  Id     string
  HashId uint32
}
</code></pre>

<p>Теперь пишем функцию для инициализации <code>Ring</code> и <code>Node</code>:</p>

<pre><code class="go">package consistenthash
func NewRing() *Ring {
  return &amp;Ring{Nodes : Nodes{}}
}
func NewNode(id string) *Node{ 
  return &amp;Node{
    Id        : id,
    hashedKey : crc32.Checksum([]byte(id)),
  }
}
</code></pre>

<p>И необходимо реализовать функцию <code>AddNode</code>:</p>

<pre><code class="go">func (r *Ring) AddNode(id string) {
  node := NewNode(id)  
  r.Nodes = append(r.Nodes, node)
  sort.Sort(r.Nodes)
}
</code></pre>

<p>Почему мы используем <code>sort.Sort</code>? Тут стоит вернуться к единичной окружности. Как максимально точно реализовать эту самую единичную окружность? Одни из вариантов, это массив, в котором последний элемент указывает на первый. Для этого мы могли бы использовать связанные списки, но чуть позже вы заметите что это лишнее.</p>

<p>Если вы попытаетесь все это запустить, Go компилятор ругнется, потому что <code>Nodes</code> не реализуют <code>sort.Sort</code> интерфейс. Давайте быстро это исправим:</p>

<pre><code class="go">package consistenthash
func (n Nodes) Len() int           { return len(n) }
func (n Nodes) Less(i, j int) bool { return n[i].HashId &lt; n[j].HashId }
func (n Nodes) Swap(i, j int)      { n[i], n[j] = n[j], n[i] }
</code></pre>

<p>И последнее, что нам осталось, это реализация метода <code>Get</code>:</p>

<pre><code class="go">func (r *Ring) Get(key string) string {
  searchfn := func(i int) bool {
    return r.Nodes[i].HashId &gt;= crc32.Checksum([]byte(key))
  }
  i := sort.Search(r.Nodes.Len(), searchfn)
  if i &gt;= r.Nodes.Len() {
    i = 0
  }
  return r.Nodes[i].Id
}
</code></pre>

<p>В методе <a href="https://golang.org/pkg/sort/#Search"><code>sort.Search</code></a> используется бинарный поиск для определения необходимой ноды в массиве. Если такой ноды не существует, то возвращается значение, указывающее куда ее нужно было бы добавить(в данной реализации нам это не нужно). Таким образом, если значение контрольной суммы выходит за рамки массива с нодами, мы просто указываем первую ноду. И на этом все.</p>

<p>Если вы хотите посмотреть как это работает, то можете <a href="https://github.com/sent-hil/consistenthash">найти исходники тут</a>. Тесты в комплекте.</p>

<p>Помните, в начале статьи говорилось что консистентное хеширование это довольно простая, но достаточно мощная практика? Уверен, теперь вы мне верите. Вам следует знать, что консистентное хеширование впервые упоминается в <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=7&amp;cad=rja&amp;uact=8&amp;ved=0CFIQFjAG&amp;url=http%3A%2F%2Fwww.akamai.com%2Fdl%2Ftechnical_publications%2FConsistenHashingandRandomTreesDistributedCachingprotocolsforrelievingHotSpotsontheworldwideweb.pdf&amp;ei=6IVAVbq9HcX6oQThqYHgDg&amp;usg=AFQjCNH2IBIOHYdoFYZae_kJsR4-H-_m-A&amp;bvm=bv.91665533,d.cGU">исследованиях Akamai</a>. Значительно более продвинутая версия консистентного хеширования используется в <a href="https://en.wikipedia.org/wiki/Chord_%28peer-to-peer%29">Chord</a> алгоритме, который, по сути, представляет собой работу с хеш таблицей (ранее считалось, что Chord появился в результате разработки амазоновской dynamodb, <a href="https://twitter.com/ernesto_jimenez/status/593550482737635328">что не совсем верно</a>).</p>

<p>В данный момент, я все еще пытаюсь разобраться с Chord алгоритмом, понять как он работает(не говоря уже о реализации). Надеюсь, как только у меня получится, то напишу еще одну статью. Я получил много удовольствия, изучая консистентное хеширования и написав этот пост. Надеюсь, вам то же понравилось. Если вы нашли ошибки или у вас есть что сказать по этому поводу, обязательно пишите мне в твиттер <a href="http://twitter.com/sent-hil">@sent-hil</a>.</p>

<h3>Ссылки по теме</h3>

<ul>
<li><a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D1%91%D0%BD%D0%BD%D0%B0%D1%8F_%D1%85%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0">Распределённая хеш-таблица</a></li>
<li><a href="https://ru.wikipedia.org/wiki/%D0%95%D0%B4%D0%B8%D0%BD%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D0%BE%D0%BA%D1%80%D1%83%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C">Единичная окружность</a></li>
<li><a href="https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B8%D0%B7%D0%B1%D1%8B%D1%82%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4">Циклический избыточный код</a></li>
</ul>
