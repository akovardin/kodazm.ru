+++
date = "2015-02-09T03:36:03+03:00"
draft = false
title = "Валидация с помощью govalidator"

+++

<p>Валидация уже очень давно применяется в самых различных веб и декстопных приложениях. Уже сломано немало копий, написана куча пакетов для различных языков программирования, решающих эту задачу. Давайте посмотрим, каким образом можно проверять данные в Go программах, используя пакет <a href="https://github.com/asaskevich/govalidator">govalidator</a>. За этот пакет огромное спасибо <a href="https://twitter.com/asaskevich">Алексею Саскевичу</a>.</p>

<h3>Валидация</h3>

<p>Валидация входных данных - это проверка этих самых данных на соответствие некоторым условиям. "Невалидные" данные, не удовлетворяющие определённым ограничениям или условиям, могут вызывать сбой в программе, порою весьма критичный. Давайте представим, что в каком-то месте выстреливает исключение, например, в момент когда программа пытается преобразовать строку некорректного формата в число. Если это исключение не обрабатывается где-то в программе, то есть вероятность, что произойдет аварийное завершение программы.</p>

<p>И падение программы - это только одна из неприятностей, которые могут произойти. Мы можем перехватывать исключение и восстанавливаться после сбоев. Однако это связанно с накладными расходами, что может ощутимо снизить производительность программы, что тоже не всегда является плюсом.</p>

<p>Кроме того, падения может вообще не произойти, но последствия от этого будут не менее плачевными. Если данные недостаточно проверяются, то это открытая дверь для внешних инъекций. Злоумышленник может получить несанкционированный доступ к данным или некоторым возможностям программы, либо способен вообще разрушить данные или программу.</p>

<p>Когда где-то внутри программы происходит исключительная ситуация, то не всегда есть возможность проследить причины ее возникновения. И даже если это возможно, то нужно как-то объяснить пользователю, что сбой вызван данными, которыми он ввел.</p>

<p>Все это и является причинами, по которым люди придумали валидировать данные, и в случае ошибочных данных немедленно сообщать об этом.</p>

<h3>Пакет govalidator</h3>

<p>Этот пакет предоставляет простой интерфейс для проверки некоторых строковых данных на соответствие определенным условиям. У всех функций примерно одинаковый формат, вида <code>func IsSomething(str string) bool</code>, причем таких функций <a href="https://github.com/asaskevich/govalidator#list-of-functions">достаточно много</a>, почти на все случаи жизни.</p>

<h4>Использование</h4>

<p>Чтобы начать пользоваться пакетом, его нужно установить в вашем рабочем окружении:</p>

<pre><code class="sh">go get github.com/asaskevich/govalidator
</code></pre>

<p>Теперь мы можем пользоваться подключить пакет <code>govalidator</code> в своем проекте и использовать его.</p>

<pre><code class="go">import (
    "github.com/asaskevich/govalidator"
)
</code></pre>

<p>Если длинное название пакета вас не устраивает, можно заменить его на более краткое, например так:</p>

<pre><code class="go">import (
    v "github.com/asaskevich/govalidator"
)
</code></pre>

<p>Функций, доступных к использованию, очень много, большинство из них имеют сигнатуру <code>IsSomething(str string) bool</code>. Кроме того, пакет имеет функции конвертации данных, например преобразование строк в числа и анонимные структуры.</p>

<p>Мы можем валидировать данные по отдельности:</p>

<pre><code class="go">fmt.Println(govalidator.IsAlphanumeric("12345"))
</code></pre>

<p>либо валидировать сразу целую структуру. Для этого удобно использовать теги <code>valid</code>, указывая таким образом, как необходимо проверить структуру. Если вы хотите применить к одному полю более одного валидатора, то перечисляйте их через запятую. В случае когда вам нужно пропустить валидацию - используйте <code>-</code> в теге <code>valid</code>:</p>

<pre><code class="go">type Post struct {
    Title    string `valid:"alphanum,required"`
    Message  string `valid:"duck,ascii"`
    AuthorIP string `valid:"ipv4"`
    Date     string `valid:"-"`
}
</code></pre>

<p>Соответствие тегов и методов валидации приведено <a href="https://github.com/asaskevich/govalidator#validatestruct-2">в этом списке</a>. Если вам чего-то не хватает, то можно добавить свой валидатор к общему списку, устройство пакета приветствует это:</p>

<pre><code class="go">govalidator.TagMap["duck"] = govalidator.Validator(func(str string) bool {
    return str == "duck"
})
</code></pre>

<p>Теперь можем проверить всю структуру сразу:</p>

<pre><code class="go">post := &amp;Post{
    Title:   "My Example Post",
    Message: "duck",
    AuthorIP: "123.234.54.3",
}
result, err := govalidator.ValidateStruct(post)
if err != nil {
    fmt.Println("error: " + err.Error())
}
fmt.Println(result)
</code></pre>

<p>Заметим, что пакет проверяет структуры рекурсивно, что еще более упрощает жизнь разработчика.</p>

<p>Как видите, использование специализированных валидаторов упрощает работу с данными.</p>

<h4>Устройство</h4>

<p>Основную роль в пакете <code>govalidator</code> играют пакеты <code>reflect</code> и <code>regexp</code>. Регулярные выражения нам нужны для сравнения строковых данных с паттернами:</p>

<pre><code class="go">package govalidator

import "regexp"

// Основные регулярные выражения для валидации строк
const (
    Alpha        string = "^[a-zA-Z]+$"
    Alphanumeric string = "^[a-zA-Z0-9]+$"
    Numeric      string = "^[-+]?[0-9]+$"
    //...
)

var (
    rxAlpha        = regexp.MustCompile(Alpha)
    rxAlphanumeric = regexp.MustCompile(Alphanumeric)
    rxNumeric      = regexp.MustCompile(Numeric)
    //...
)
</code></pre>

<p>Все регулярные выражения в пакете сразу компилируются, уменьшая время работы каждого валидатора.</p>

<p>Пакет <code>reflect</code> используется для работы с типами, а также валидации структур. Так же при помощи него мы можем разбирать теги структур, а это не возможно без пакета <code>reflect</code>:</p>

<pre><code class="go">// ValidateStruct используем теги для полей структуры
func ValidateStruct(s interface{}) (bool, error) {
    if s == nil {
        return true, nil
    }
    result := true
    var err error
    val := reflect.ValueOf(s)
    if val.Kind() == reflect.Interface || val.Kind() == reflect.Ptr {
        val = val.Elem()
    }
    //...
}
//...
</code></pre>

<h3>Аналоги</h3>

<p>Одним из самых ближайших аналогов является пакет <a href="https://github.com/go-validator/validator">github.com/go-validator/validator</a>. Этот пакет также может валидировать структуры целиком, однако его функционал значительно беднее.</p>

<p>Вероятно, если вы пишете веб приложение, то вам стоит обратить внимания на более веб-ориентированные решения, такие как <a href="https://github.com/absoludity/goforms">github.com/absoludity/goforms</a>. Преимущество таких пакетов в том, что они являются надстройкой над <code>http.Request</code> и используются для удобной работы с формами, в том числе и валидации данных из этой формы. Конечно, это значительно менее универсальный подход, который ограничивает область валидации данных.</p>

<h3>Аналоги в других языках</h3>

<p>Проблема валидации данных не нова, уже существует достаточное множество решений, разработанных с учетом потребностей пользователей, а также языков реализации. Самым ближайшим "родственником" данного пакета является JavaScript пакет <a href="https://github.com/chriso/validator.js">validator.js</a>. В языке Java сходную задачу решает <a href="http://beanvalidation.org/">BeanValidation</a>.</p>

<h3>Отзывы пользователей</h3>

<p>Естественно, всегда найдутся критики, которые не только укажут на недостаток, но и помогут его решить. К примеру, некоторые были удивлены тем, что некоторые функции пакета являются просто надстройкой над стандартными функциями Go. Некоторые были удивлены тем, что проверка email адресов производится на основе регулярного выражения. По их мнению, гораздо лучше послать сообщение конечному пользователю, убедившись таким образом не просто в корректности адреса, а в его реальности. Но в целом пакет принят комьюнити и активно им поддерживается, за полгода существования приняты и внесены десятки пулл-реквестов, улучшающих пакет в разы.</p>

<h3>Заключение</h3>

<p>Валиция всегда была и остается очень важной проблемой, которая должна решаться в рамках любого приложения. К счастью, уже написано множество пакетов, которые выполняют за нас часть работы. Для внедрения максимально надежной, гибкой  и универсальной валидации данных можно и нужно использовать пакет <a href="https://github.com/asaskevich/govalidator">govalidator</a>.</p>
