+++
date = "2015-07-18T14:56:02+03:00"
draft = false
title = "PHP расширение и Go"

+++

<p>Пока все меряются паузами GC в новой версии Go, я потихоньку линкую его к PHP.  Да-да, именно так, в свежем Go появилась возможность билдить код как статическую или динамическую библиотеку. Таким образом, теперь можно использовать код на Go в самых разных сишных проектах, в том числе и для PHP расширений.</p>

<p>Конечно, с практической стороны, в таком использовании Go мало пользы, но вполне вероятно, что в будущем этот найдет применение.</p>

<p>К сожалению, я не обладают большим опытом работы с сишным кодом, поэтому буду рад любым дополнениям и исправлениями.</p>

<p>В этом эксперименте использоваться самый свежий Go на данный момент - 1.5beta2.</p>

<h3>Правильно готовим Go</h3>

<p>И так, начнём с поисков последней версии Go. Я достаточно ленив, поэтому использую gvm для управлениями версиями языка на своей машине. Используя <a href="https://github.com/moovweb/gvm">gvm</a> устанавливаемые последнюю версию Go.</p>

<pre><code>% gvm install go1.5beta2
% gvm use go1.5beta2
</code></pre>

<p>Подготовим наш Go проект, который будет собираться в сишную либу. Файл src/arch/main.go:</p>

<pre><code class="go">package main

import "C"
import (
    "fmt"
)

func main() {

}

//export HelloFromGo
func HelloFromGo() {
    fmt.Println("hello")
}
</code></pre>

<p>Как видите, мы используем cgo, помечаем нужные нам функции как <code>//export НазваниеФункцииВСишномКоде</code> и, что совсем уж странно, тут есть функция <code>main</code>. Не переживайте, она не будет нам мешать - компоновщик в Go достаточно умен.</p>

<p>На самом, деле вся магия всего лишь в одном параметре для сборки: buildmode. Мы указываем его значение как <code>-buildmode=c-archive</code> и это позволяет собрать статичную либу:</p>

<blockquote>
  <p>Собирать перечисленные main пакеты и все пакеты, которые они импортируют в архив для языка C. Только необходимые функции будут помеченные как экспортируемые. Не main пакеты будут игнорироваться.</p>
</blockquote>

<p>Получить больше информации в об этом параметре можно в хелпе:</p>

<pre><code>% go help buildmode
</code></pre>

<p>Вот так выглядит структуру проекта для нашего экспериментирования:</p>

<pre><code>|- src/
    |- arch/
          |- main.go
|- lib/
|- php/
</code></pre>

<p>Папка src используется для Go пакетов. Папка lib нужна для результатов <code>go build</code> и в ней будем хранить нашу статичную либу. Ну а  в папке php будем пилить расширение.</p>

<p>Теперь можно собирать либу:</p>

<pre><code class="sh">% env GOPATH=$(pwd) go build -buildmode=c-archive -o ./lib/libhello.a -v arch
</code></pre>

<p>В результате, в папке lib у нас будет два файла: libhello.h и libhello.a. Это именно то, что нам нужно.</p>

<p>Не смущайтесь формату команды. Я устанавливаю переменную GOPATH для удобства работы с проектом.</p>

<h3>Учимся писать PHP расширения</h3>

<p>Прежде всего, делаем скелет расширения. Сначала нам необходим файл с прототипом публичных функций, которые будут реализованы в нашем расширении и которые будут доступны в пользовательском пространстве PHP ./php/hello.def.</p>

<pre><code>Hello()
</code></pre>

<p>Начнем с вот такого простого концепта. Пока нам важно только проверить работоспособность нашей идеи.</p>

<p>Запускаем специальный скрипт, который сгенерирует скелет расширения.</p>

<pre><code class="sh">% cd ./php
% ~/.phpbrew/build/php-5.6.10/ext/ext_skel --extname=hello --proto=./hello.def \
--skel=/home/artem/.phpbrew/build/php-5.6.10/ext/skeleton
</code></pre>

<p>Я использую phpbrew для PHP, так же как gvm для Go. Это сильно упрощает поддержание актуальной версии PHP на моей машине. Если вы не хотите использовать phpbrew, то вам придется самим затянуть исходники.</p>

<ul>
<li><code>--extname=hello</code> - Название расширения.</li>
<li><code>--proto=./hello.def</code> - Указываем файл с прототипом функций.</li>
<li><code>--skel=/home/artem/.phpbrew/build/php-5.6.10/ext/skeleton</code> Стандартная заготовка для расширений.</li>
</ul>

<p>После запуска этого скрипта, у вас появится папка hello, в которой будет все необходимое для расширения. Не забывайте про утилиту phpize</p>

<pre><code>% cd ./php/hello
% phpize
</code></pre>

<p>После генерации скелета для нового расширения, нужно немного его настроить:</p>

<pre><code>PHP_ARG_WITH(hello, for hello support,
[  --with-hello             Include hello support])

if test "$PHP_HELLO" != "no"; then

  PHP_SUBST(HELLO_SHARED_LIBADD)

  PHP_ADD_LIBRARY_WITH_PATH(hello, ../../lib, HELLO_SHARED_LIBADD)
fi
</code></pre>

<p><code>PHP_ADD_LIBRARY_WITH_PATH</code> - таким образом мы указывает что расширение нужно будет собирать с нашей либой.</p>

<p>И теперь используем функцию из Go в нашем расширении:</p>

<pre><code>#include "../../lib/libhello.h"

//...

PHP_FUNCTION(Hello)
{
    if (zend_parse_parameters_none() == FAILURE) {
        return;
    }

    HelloFromGo();
}
</code></pre>

<p>Все готово для сборки нашего расширения:</p>

<pre><code>% ./configure
% make &amp;&amp; make install
</code></pre>

<p>Осталось подключить сошку в php.ini и написать маленький тест.</p>

<pre><code>extension=hello.so
</code></pre>

<p>И используем новую функцию:</p>

<pre><code class="php">&lt;php

Hello();
</code></pre>

<p>Худо-бедно это работает. Конечно, я и в коем случае не рекомендую использовать это(ну, по крайней мере пока). Кроме того, пока так и не получилось заставить работать такое расширение стабильно и без периодических сегфолтов. Однако, сама идея и возможность реализации греют душу.</p>

<p>Весь код <a href="https://github.com/4gophers/gophp">можно посмотреть на гитхабе</a>.</p>

<h3>Ссылки</h3>

<ul>
<li>Как <a href="http://adobkin.com/2013/03/03/sozdaniie-rasshirieniia-dlia-php/">писать расширения для PHP</a>.</li>
<li>Проект <a href="http://phpbrew.github.io/phpbrew/">phpbrew</a>.</li>
<li>Документация <a href="https://tip.golang.org/doc/go1.5">по новой версии Go</a>.</li>
</ul>
