+++
date = "2016-05-30T01:18:01+03:00"
draft = false
title = "Делаем свой контейнер в 100 строчек кода"

+++

<p>Перевод статьи "<a href="http://www.infoq.com/articles/build-a-container-golang">Build Your Own Container Using Less than 100 Lines of Go</a>"</p>

<p>Docker зарелизился в марте 2013 и произвел довольно громкий переворот в индустрии програмного обеспечения, изменив подход к упаковке и деплою современных приложений. После Docker появилось много различных приложений, которые используют или дополняют Docker, а затем настал момент понимания, что контейнеризация все еще не серебрянная пуля. Цель этой статьи - избавиться от налета таинственности и рассказать как все работает на самом деле.</p>

<p>В этой серии статей мы поговорим о технологиях, которые лежат в основе контейнеров, что сейчас пользуется популярностью у разработчиков, рассмотрим частые проблемы, возникающие при развертывании контейнеров(например, интеграция с CI и СD) и поговорим о мониторинге при переменной нагрузке и частой смене потенциалов. В заключении мы помечтаем о будущем контейнеризации и обсудим, какой популярностью пользуется unikernels в самых передовых организациях.</p>

<p>Эта статья одна из серии "<a href="http://www.infoq.com/containers-real-world-hype-curve">Containers in the Real World - Stepping Off the Hype Curve</a>". Вы можете подписаться на обновления через RSS.</p>

<p>Проблема всех аналогий в том, что они, как правило, выключают ваш мозг, когда вы их слышите. Некоторые считают, что архитектура програмного обеспечения это "просто как" архитектура зданий. Но на самом деле, это не так. А очень удачное звучание такой аналогии приносит еще больше вреда. Продолжая тему аналогий, вспомним, что контейнеры часто ассоциируют с транспортными контейнерами. Можно сказать, что контейнеры можно перемещать "просто как" обычные грузовые контейнеры. Но это не совсем так. И такая аналогия скрывает множество деталей.</p>

<p>Чтобы реально понимать что такое контейнеры и какое место они занимают в мире разработки ПО, необходимо понимать как они работают. И в этой статье мы как раз об этом поговорим. Узнаем отличия между контейнерами и контейнеризацией, обсудим контейнеры в Linux (включая namespace, cgroup и слоенные файловые системы). Напишем немного кода, чтобы создать простой контейнер с нуля, и, наконец, сделаем выводы и посмотрим куда нас все это приведет.</p>

<h3>Что такое контейнеры на самом деле?</h3>

<p>Я люблю играть в игры. Давайте сыграем в одну прямо сейчас. Представте, что вам нужно ответить на вопрос "что такое контейнер?". Ответили? Попытаюсь угадать ваши ответы:</p>

<ul>
<li>Способ совместного использования ресурсов.</li>
<li>Изоляция процессов.</li>
<li>Один из способов легкой виртуализации.</li>
<li>Упаковка корневой файловой системы и метаданных вместе.</li>
<li>Своеобразная chroot тюрьма.</li>
<li>Что-то вроде транспортного контейнера.</li>
<li>Все что делает докер.</li>
</ul>

<p>Посмотрите, одно слово означает довольно много вещей. Так сложилось, что слово "контейнер" стали использовать для обозначения большого количества различных концепций. Оно используется как для определения аналогии с контейерезацией, так и для определения технологий для реализации контейнеров. Если рассматривать их по отдельности, то все становится прозрачнее. И так, давайте поговорим, зачем нам нужны контейнеры. А затем узнаем, как нам этого добиться(и потом снова вернемся к первому вопросу).</p>

<h3>В начале</h3>

<p>В начале была программа. Представим, что у нас есть некоторая программа <code>run.sh</code>, которую мы собираемся скопировать на сервер и там запустить. Но вот такой бездумный запуск программ на удаленном сервере - это дело не благородное, а порой даже не безопасное. Именно поэтому люди изобрели виртуальные серверы и права доступа. И все было хорошо.</p>

<p>Но простой запуск <code>run.sh</code> не возможен без наличия всех необходимых ему зависимостей. Нужны определенные библиотеки, установленные на этом хосте. Кроме того, программы, как правило, не хотят работать одинаково на локальном хосте и на удаленном(и не пробуйте меня переубеждать). В результате мы изобрели AMI (Amazon Machine Images), и VMware образы, Vagrantfile, и многое другое. И все было хорошо.</p>

<p>Почти хорошо. Все эти пачки образов сложно было доставлять конечному потребителю, они были неоправданно большими и очень плохо стандартизированными. Поэтому, мы придумали кеширование.</p>

<p><img src="https://cdn.infoq.com/statics_s2_20160414-0116u1/resource/articles/build-a-container-golang/en/resources/fig1.jpg" alt="" /></p>

<p>И все опять стало хорошо.</p>

<p>Кеширование - это именно то, что очень выгодно отличает Docker контейнеры от VMDK или Vagrantfile. Теперь мы можем работать только с дельтами базовых образов, а не с полными огромными образами. Это означает, что мы можем запаковать рабочую среду и перенести ее на другую машину. Вот почему, когда вы запускаете <code>docker run whatever</code>, то Docker поднимается очень быстро, даже если это выглядит как запуск нового образа системы. Мы поговорим о том, как это работает чуть позже.</p>

<p>И вот теперь мы можем сказать, что такое контейнеры на самом деле. Это инструмент для сборки зависимостей таким образом, чтобы мы могли запускать код где угодно воспроизводимо и безопасно. Но это все определения на очень высоком уровне. Давайте поговорим о реализации.</p>

<h3>Создание контейнеров</h3>

<p>И так, что такое контейнер в более практическом смысле? Бы ло бы очень замечательно, если контейнер создавался с помощью системного вызова <code>create_container</code>. Но, к сожалению, это не так. Хотя, если откровенно, то не многим сложнее.</p>

<p>Чтобы говорить о контейнерах на более низком уровне, нам нужно разбираться в трех вещах: пространствах имен(namespaces), cgroups, и слоенных файловых системах(layered filesystems). Конечно, нужно еще много всего, но именно эти три вещи делают всю магию.</p>

<h3>Пространства имен</h3>

<p>Пространства имен предоставляют изоляцию необходимую для запуска нескольких контейнеров на одной машине, при этом каждый контейнер работает в собственном окружении. На текущий момент существует шесть пространств имен. Каждое из них может независимо от других предоставлять определенному процессу или его потомку различные ресурсы машины.</p>

<p>Пространства имен бывают:</p>

<ul>
<li><em>PID</em>: Это пространство имен предоставляет процессу и его потомкам собственное видение набора процессов в системе. Это можно представить себе как таблицу соответствия. Когда процесс в пространстве PID запрашивает у системы список процессов, то ядро сначало смотрит в эту таблицу соответствия. Если процесс существует в этой таблице, то используется соответствующий ID вместо реального ID. Если же процесса нет в таблице, то ядро делает вид, что процесса вообще не существует. Пространство PID задает первому процессу ID 1, таким образом, мы можем изолировать дерево процессов для каждого контейнера.</li>
<li><em>MNT</em>: Это одно из самых важных пространств имен. Оно предоставляет процессу отдельные таблицы монтирования. Это значит, что процесс может монтировать и отмонтировать необходимые директории не затрагивая других пространств имен(в том числе и основное). И еще один важный момент: в сочетании с использованием системного вызова pivot_root мы можем позволить процессу иметь свою собственную файловую систему. Именно благодаря этой фиче, просто переключая файловые системы, которые видит контейнер, мы можем сделать вид, что процесс запущен на ubuntu, busybox или alpine.</li>
<li><em>NET</em>: Сетевое пространство имен предоставляет процессу возможность использовать свой собственный сетевой стек. Конечно, только процессы из главного сетевого пространства имен (те, которые запускаются, когда вы включаете компьютер) имеют доступ к реальным сетевым картам. Но мы можем создавать виртуальные изернет пары - виртуально связанные сетевые карты в разных пространствах имен. Это выглядит как наличие нескольких ip стеков на одной машине, которые могут общаться друг с другом. Если добавить немного магии роутинга, то можно предоставить контейнерам доступ в реальный мир, несмотря на изоляцию в своем собственно ip стеке.</li>
<li><em>UTS</em>: Пространство имен предоставляет процессу возможность иметь свои собственные имена для хоста и домена. После настройки пространства имен UTS, любые изменения имени хоста или домена не затронут другие процессы.</li>
<li><em>IPC</em>: Это пространство имен изолирует механизм межпроцессорного взаимодействия, таких как очередь сообщений. Для более глубокого понимания, <a href="http://man7.org/linux/man-%20pages/man7/namespaces.7.html">загляните в документацию</a>.</li>
<li><em>USER</em>: Это пространство имен было добавленно совсем недавно и именно настройка этого пространства оказывает наибольшее влияние на безопасность работы контейнера. Пространство USER выполняет мапинг между UID'ами в рамках процесса к UID'ами (и GID'ами) самого хоста. Это очень полезно. Используя это пространство имен, мы можем привязать ID пользователя root в контейнере (например 0) к произвольному и непривилегированному UID на реальном хосте. Таким образом, мы можем предоставить root доступ к ресурсам внутри контейнера, но, на самом деле, не предоставляя root права в рамках всего хоста. Контейнер может запускать процессы с UID 0 (что означает root пользователя) но в ядре будет происходить мапинг этого UID с некоторым непривилегированном реальным UID. Большинство систем контейнеризации не мапят UID внутри контейнера на нулевой UID в вызывающем пространстве.</li>
</ul>

<p>Почти все современные системы контейнеризации размещают пользовательский процесс во всех указанных пространствах имен для создания специального окружения. Это необходимо, как пример, для создания некоторой исходной сети внутри изолированного сетевого пространства имен с возможностью подключения к реальной сети.</p>

<h3>Cgroups</h3>

<p>Cgroups это тема для отдельной статьи и не одной (думаю, я когда ни будь этим займусь). В рамках этого туториала я опишу их совсем кратко. Если есть желание или проблемы с пониманием основной концепции, то всегда можете обратиться к официальной документации.</p>

<p>Если рассматривать cgroups поверхностно, то это такой механизм, с помощью которого можно собрать некоторый набор идентификаторов задач и применить к этому набору определенные ограничения. В то время, как пространства имен позволяют изолировать процесс, cgroups позволяют справедливо(или не справедливо) распределить ресурсы между процессами.</p>

<p>Cgroups предоставляются ядром как специальная файловая система, которую вы можете примонтировать. Вы можете добавить процесс или поток в cgroup просто указав идентификатор в специальном файле задач, а затем выполнять тонкую настройку просто редактируя этот файл.</p>

<h3>Слоенный файловые системы</h3>

<p>Пространства имен и cgroups это инструменты отвечающие за изоляцию и распределения ресурсов для процессов. Это большие стальные ящики и суровые охранники в порту. Слоенные файловые системы это инструмент, который позволяет перемещать целые образы машин. Если продолжить сравнение с портом, то это механизм, который позволяет кораблю плыть с контейнерами на борту.</p>

<p>На базовом уровне, слоенные файловые системы оптимизируют создание копий основных файловых систем для каждого контейнера. Это можно сделать различными способами. <a href="https://btrfs.wiki.kernel.org/">Btrfs</a> использует копирование при записи на уровне файловой системы. <a href="https://en.wikipedia.org/wiki/Aufs">Aufs</a> использует "объединенное монтирование". Способов действительно очень много. В рамках этой статьи мы будем использовать самый простой: просто делать копию. Это очень медленный способ но он работает и прост для понимания.</p>

<h3>Создание контейнера по шагам</h3>

<h4>Шаг первый. Создаем шаблон приложения</h4>

<p>Для начала создадим базовый шаблон. Я предполагаю, что у вас установленна последняя <a href="https://golang.org/doc/install">версия языка Go</a>. Все начинается с вот такого простого кода:</p>

<pre><code>package main

import (
    "fmt"
    "os"
    "os/exec"
    "syscall"
)

func main() {
    switch os.Args[1] {
    case "run":
        parent()
    case "child":
        child()
    default:
        panic("wat should I do")
    }
}

func parent() {
    cmd := exec.Command("/proc/self/exe", append([]string{"child"}, os.Args[2:]...)...)
    cmd.Stdin = os.Stdin
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr

    if err := cmd.Run(); err != nil {
        fmt.Println("ERROR", err)
        os.Exit(1)
    }
}

func child() { 
    cmd := exec.Command(os.Args[2], os.Args[3:]...)
    cmd.Stdin = os.Stdin
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr

    if err := cmd.Run(); err != nil {
        fmt.Println("ERROR", err)
        os.Exit(1)
    }
}

func must(err error) {
    if err != nil {
        panic(err)
    }
}
</code></pre>

<p>Что делает этот код? Мы читаем первый аргумент, если это строка <code>"run"</code>, то запускается метод <code>parent()</code>, а если это строка <code>"child"</code>, то запускаем метод <code>child()</code>. В методе <code>parent()</code> запускается специальный файл <code>/proc/self/exe</code>, который содержит образ памяти для текущего исполняемого файла. Другими словами, мы заново запускаем себя же, но с указанием параметра <code>"child"</code>.</p>

<p>Что это за сумашествие? Ну, на самом деле, это еще не очень большое сумашествие. Просто, теперь мы можем запускать другу программу, которая, в свою очередь, запускает программу указанную пользователем(параметр <code>os.Args[2:]</code>). Теперь у нас есть каркас, перейдем к созданию контейнера.</p>

<h4>Шаг второй. Используем пространства имен</h4>

<p>Чтобы начать использовать пространства имен, достаточно добавить одну строчку кода. Просто вставляем указанный ниже коду на вторую строку метода <code>parent()</code>. Таким образом, мы добавим специальные флаги, которые будут влиять на запуск дочернего процесса.</p>

<pre><code>cmd.SysProcAttr = &amp;syscall.SysProcAttr{
    Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS,
}
</code></pre>

<p>Теперь ваша программа будет запускаться внутри пространств имен UTS, PID и MNT.</p>

<h4>Шаг третий. Корневая файловая система.</h4>

<p>Теперь наш процесс запускается изолированно, с установленным набором пространств имен (можете поэксперементировать, добавляя флаги для использования других пространств). Но файловая система такая же, что и на хостовой машине. Так и должно быть, несмотря на то, что указан флаг для использования пространства имен <code>MNT</code>, но начальные точки монтирования унаследованы от родительского пространства имен.</p>

<p>Давайте изменим это. Нам нужно добавить несколько строчек кода, чтобы переключится в корневую файловую систему. Добавим код в функцию <code>child()</code>.</p>

<pre><code>must(syscall.Mount("rootfs", "rootfs", "", syscall.MS_BIND, ""))
must(os.MkdirAll("rootfs/oldrootfs", 0700))
must(syscall.PivotRoot("rootfs", "rootfs/oldrootfs"))
must(os.Chdir("/"))
</code></pre>

<p>Две последние строчки самые важные, они сообщают файловой системе, сменить текущую директорию с <code>/</code> на <code>rootfs/oldrootfs</code>, и переключить новую rootfs директорию на <code>/</code>. После вызова <code>pivotroot</code>, директория <code>/</code> внутри контейнера указывает на rootfs (биндинг при монтировании необходим, чтобы удовлетворить требованиям команды <code>pivotroot</code> - OS требует использовать <code>pivotroot</code> для переключения файловых систем, котрые не являются частями одного дерева)</p>

<h4>Шаг четвертый. Инициализация мира контейнера</h4>

<p>На текущий момент, у нас есть процесс, запущенный с набором изолированных пространств имен, с своей собственной корневой файловой системой. Мы не стали рассматривать настройку cgroups, хоть это и достаточно просто. Также, мы не занимались настройкой, которая позволила бы эффективно скачивать и кешировать корневую файловую систему.</p>

<p>И мы пропустили этап настройки самого контейнера. Сейчас у нас есть сырой контейнер, запущенный с использованием изолированных пространствах имен. Мы настроили <code>MNT</code> пространство, но все остальное осталось по умолчанию. В реальной жизни, нам нужно было бы настроить "мир" контейнера перед запуском пользовательского процесса. К примеру, мы могли бы настроить сеть, переключится на необходимый UID до запуска процесса, установить необходимые лимиты (например, rlimits) и так далее. Но это уже больше чем 100 строчек кода.</p>

<h4>Шаг пятый. Собираем все вместе</h4>

<p>И вот, все готово. Очень-очень простой контейнер, менее чем на 100 строк кода. Конечно же, мы специально делали его таким простым. Если вы вздумаете использовать его в продакшене, то вас сразу заберут в дурку. Но, тем не менее, это наше творчество дает хорошее представление о том, как устроены контейнеры.</p>

<pre><code>package main

import (
    "fmt"
    "os"
    "os/exec"
    "syscall"
)

func main() {
    switch os.Args[1] {
    case "run":
        parent()
    case "child":
        child()
    default:
        panic("wat should I do")
    }
}

func parent() {
    cmd := exec.Command("/proc/self/exe", append([]string{"child"}, os.Args[2:]...)...)
    cmd.SysProcAttr = &amp;syscall.SysProcAttr{
        Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS,
    }
    cmd.Stdin = os.Stdin
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr

    if err := cmd.Run(); err != nil {
        fmt.Println("ERROR", err)
        os.Exit(1)
    }
}

func child() {
    must(syscall.Mount("rootfs", "rootfs", "", syscall.MS_BIND, ""))
    must(os.MkdirAll("rootfs/oldrootfs", 0700))
    must(syscall.PivotRoot("rootfs", "rootfs/oldrootfs"))
    must(os.Chdir("/"))

    cmd := exec.Command(os.Args[2], os.Args[3:]...)
    cmd.Stdin = os.Stdin
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr

    if err := cmd.Run(); err != nil {
        fmt.Println("ERROR", err)
        os.Exit(1)
    }
}

func must(err error) {
    if err != nil {
        panic(err)
    }
}
</code></pre>

<h3>К чему все это?</h3>

<p>Тут я буду немного противоречивым. Для меня, контейнеры это способ доставки кода куда угодно и инструмент для дешевого(в плане ресурсов) изолированного запуска процесса, но это еще не конец истории. Контейнеры - это набор технологий, а не пользовательский опыт и умения.</p>

<p>Как пользователь, я хочу пользоваться контейнерами не больше чем покупатель использует amazon.com для приобретения нового телефона - ему не приходиться договариваться о отгрузке товара в порту. Контейнеры - это фантастическая технология, которая построена поверх многих инструментов и нам не приходиться отвлекаться на способы разворачивания образов вместо действительно важных дел.</p>

<p>Платформы как Сервис(PaaS), такие как <a href="https://www.cloudfoundry.org/">Cloud Foundry</a>, построенные поверх контейнеров, начинали именно с управления кодом, а не с контейнеризации. Большинства разработчиков просто хочет запустить свое приложение нажатием одной кнопки. За кулисами таких сервисов происходит много всего: запускаются контейнеры, как-то настраиваются и т.д. В случае с Cloud Foundry вы можете вообще пропустить этот шаг и использовать подготовленные Docker файлы.</p>

<p>Тем не менее, используя PaaS вся гибкость и мощь контейнеров никуда не девается. Это и управление ресурсами, создание сред и т.д. При этом добавляется возможность использовать простой пользовательский интерфейс, который не требует от разработчика большого опыта и познания в области контейнеров. Кроме того, всегда можно быстро и незаметно добавить быстрые заплатки уязвимости. Базы данных, очереди сообщение и различные сторонние сервисы могут быть представленны как услуги, которые можно привязать к вашему приложению и, таким образом, вообще не замечать, что все построено на контейнерах.</p>
