+++
date = "2015-01-12T18:30:06+03:00"
draft = false
title = "Генерация кода"

+++

<p>Перевод статьи от Роба Пайка про генерацию кода. Из <a href="http://blog.golang.org/generate">официального блога</a>.</p>

<p>Свойство универсальных вычислений - Тьюринг полнота - это способность одной программы написать другую программу. Это мощная идея, которая, как правило, остается недооцененной. Например, это одна из основных частей, определяющих компилятор. Так же, по этому принципу работает команда для тестирования: сначала сканируются пакеты, которые должны быть протестированы, создается временная программа содержащая обвязку для тестов и кастомизированная для конкретного пакета, затем эта временная программа компилируется и запускается. Хотя это довольно большая последовательность действий, современные компьютеры достаточно быстры, чтобы выполнить ее за миллисекунды.</p>

<p>Есть много других примеров, когда программы пишут программы. <a href="http://golang.org/cmd/yacc/">Yacc</a>, к примеру, читает описание грамматики и генерирует программу, которая может разбирать эту грамматику. "Компилятор" протобафа(<a href="http://code.google.com/p/protobuf/">Protocol Buffers</a>) читает описание интерфейсов и генерирует определения структур, методов и другой сопутствующий код. Различные средства конфигурации работают аналогичным способом, получая информацию о окружении и генерируя различные скрипты, кастомизированные под конкретное окружение.</p>

<p>Программы которые пишут другие программы - это важный элемент в разработке программного обеспечения. Но программы типа Yacc генерируют код, который должен быть интегрирован в процессе сборки, то есть, результат может быть скомпилирован. Когда используются сторонние инструменты сборки, такие как Make, то это становится простой задачей. Но в Go инструменты сборки получают всю информацию только из исходников .go и это становится проблемой. Просто нет механизма для запуска с Yacc помощью go инструментов.</p>

<p>Но теперь такая возможность появилась.</p>

<p><a href="http://blog.golang.org/go1.4">Последний релиз Go 1.4</a> включает новую команду, которая упрощает запуск таких тулз. Она называется <code>go generate</code>.  Работает сканируя определенные комментарии в исходниках go кода, которые определяют какие средства генерации нужно запустить. Важный момент для понимания: <code>go generate</code> не является частью <code>go build</code>. Эта команда не анализирует зависимости и должна запускаться до <code>go build</code>. Кроме того, генерация должна использоваться только автором пакета, но не его пользователями.</p>

<p>Использовать <code>go generate</code> довольно просто. Для разминки, посмотрим как генерировать Yacc грамматики. Предположим, у вас есть входной файл gopher.y который описывает грамматики для вашего нового языка. Для получения исходника .go реализующего эту грамматику, нам, как правило, нужно вызвать стандартную версию yacc для Go:</p>

<pre><code class="sh">go tool yacc -o gopher.go -p parser gopher.y
</code></pre>

<p>Параметр <code>-o</code> определяет имя выходного файла, <code>-p</code> указывает пакет.</p>

<p>Чтобы воспользоваться командой <code>go generate</code> в любом не генерируемом .go файле укажите специальный комментарий в любом месте файла:</p>

<pre><code class="go">//go:generate go tool yacc -o gopher.go -p parser gopher.y
</code></pre>

<p>Этот текст просто команда, описанная выше, со специальным префиксом комментария который распознается с помощью <code>go generate</code>. Этот комментарий должен стоять в начале строки и не должно быть пробелов между <code>//</code> и <code>go:generate</code>. После этого маркера идет команда которая будет выполнятся в момент запуска <code>go generate</code>.</p>

<p>Теперь запустим все это. Заходим в директорию с проектом и выполняем <code>go generate</code> затем <code>go build</code> и так далее:</p>

<pre><code class="sh">$ cd $GOPATH/myrepo/gopher
$ go generate
$ go build
$ go test
</code></pre>

<p>Вот так это работает. Предположим, что у нас не было никаких ошибок, команда <code>go generate</code> запустила yacc который создаст gopher.go. После этого у нас будут все необходимые файлы для сборки проекта, тестирования и нормальной работы. После каждой модификации gopher.y необходимо просто запустить <code>go generate</code> для перегенерирования парсера.</p>

<p>Смотрите документацию для более подробного понимания работы <code>go generate</code>, включая параметры, переменные окружения и все остальное.</p>

<p>Эта команда не делает ничего, что нельзя сделать с помощью Make или других инструментов сборки, но теперь это идет в коробке и прекрасно вписывается в Go экосистему. Только не забывайте, это инструмент для разработчиков пакетов но не для их пользователей. Кроме того, если пакет должен быть получен с помощью <code>go get</code>, как только файл будет сгенерирован и оттестирован он должен быть добавлен в систему контроля версий и быть доступным для клиентов.</p>

<p>Теперь попробуем что то новенькое. Совершенно другой пример выгоды от <code>go generate</code> - возможность использовать программу stringer доступную как часть <a href="https://godoc.org/golang.org/x/tools">golang.org/x/tools</a>. Эта программа автоматически генерирует строковые методы для наборов целочисленных констант. Она не является частью стандартной поставки, но ее легко установить дополнительно:</p>

<pre><code class="sh">$ go get golang.org/x/tools/cmd/stringer
</code></pre>

<p>Пример из документации самого stringer. Представим, у нас есть код, содержащий интовые константы, которые определяют различные типы таблеток:</p>

<pre><code class="go">package painkiller

type Pill int

const (
    Placebo Pill = iota
    Aspirin
    Ibuprofen
    Paracetamol
    Acetaminophen = Paracetamol
)
</code></pre>

<p>Для отладки неплохо было бы красиво и информативно выводить отображать константы, что означает, нам нужен метод с такой сигнатурой:</p>

<pre><code class="go">func (p Pill) String() string
</code></pre>

<p>Который реализуется вот так:</p>

<pre><code class="go">func (p Pill) String() string {
    switch p {
    case Placebo:
        return "Placebo"
    case Aspirin:
        return "Aspirin"
    case Ibuprofen:
        return "Ibuprofen"
    case Paracetamol: // == Acetaminophen
        return "Paracetamol"
    }
    return fmt.Sprintf("Pill(%d)", p)
}
</code></pre>

<p>Конечно, есть и другие способы, чтобы написать эту функцию. Мы можем использовать слайс со строками и <code>Pill</code> в качестве индексов, или мапы, или другие способы. Но в любом случае, мы должны следить за списком таблеток и за правильностью этой функции (два названия парацетамола сделают эту задачу еще сложнее). Кроме того, сам вопрос какой подход использовать зависит от типов и значений: знаковые и беззнаковые, с нуля или нет и так далее.</p>

<p>Программа stringer заботиться о всех деталях. Хотя она может быть запущена отдельно, но также ее можно использовать совместно с <code>go generate</code>. Чтобы заюзать это, добавьте специальный комментарий рядом с определением типа:</p>

<pre><code class="go">//go:generate stringer -type=Pill
</code></pre>

<p>Это правило означает, что должна запуститься программа stringer, которая сгенерирует <code>String</code> метод для типа <code>Pill</code>. Результат работы программы запишется в файл pill_string.go (это название по умолчанию, его можно изменить с помощью флага <code>-o</code>).</p>

<p>Давайте запустим это:</p>

<pre><code class="sh"><br />$ go generate
</code></pre>

<p>Содержимое файла pill_string.go:</p>

<pre><code class="go">// generated by stringer -type Pill pill.go; DO NOT EDIT

package pill

import "fmt"

const _Pill_name = "PlaceboAspirinIbuprofenParacetamol"

var _Pill_index = [...]uint8{0, 7, 14, 23, 34}

func (i Pill) String() string {
    if i &lt; 0 || i+1 &gt;= Pill(len(_Pill_index)) {
        return fmt.Sprintf("Pill(%d)", i)
    }
    return _Pill_name[_Pill_index[i]:_Pill_index[i+1]]
}
</code></pre>

<p>Теперь при изменении типа <code>Pill</code>, нам просто нужно будет запустить</p>

<pre><code class="sh">$ go generate
</code></pre>

<p>для обновления строкового метода. И, конечно, если у нас несколько типов должны быть настроены подобным образом, мы также будем запускать только одну команду для обновления всех <code>String</code> методов.</p>

<p>Без сомнения, сгенерированный метод уродский. Это нормально, потому что люди не будут работать в рамках этого метода, а машино-сгенерированный код всегда уродский. Все имена объединены вместе в одну строку, которая сохраняется в памяти(только одно строка для всех имен, даже если имен будет 100500 миллионов). Дальше идет массив <code>_Pill_index</code> с индексами для имен, реализующий простую технологию, аналогичную <code>map</code>. Обратите внимание, что <code>_Pill_index</code> именно массив(а не слайс) с элементами типа uint8 - самый легкий интовый тип достаточный для охвата всего диапазона значений. Если у нас будет больше значений или появятся отрицательные, тогда, при генерации, тип автоматически замениться на более подходящий.</p>

<p>Подход, реализуемый в строковом методе который генерируется с помощью stringer, так же может меняться в зависимости от списка констант. К примеру, если константы не большие, можно использовать <code>map</code>. Вот тривиальный пример для констант степеней двойки:</p>

<pre><code class="go">const _Power_name = "p0p1p2p3p4p5..."

var _Power_map = map[Power]string{
    1:    _Power_name[0:2],
    2:    _Power_name[2:4],
    4:    _Power_name[4:6],
    8:    _Power_name[6:8],
    16:   _Power_name[8:10],
    32:   _Power_name[10:12],
    ...,
}

func (i Power) String() string {
    if str, ok := _Power_map[i]; ok {
        return str
    }
    return fmt.Sprintf("Power(%d)", i)
}
</code></pre>

<p>Проще говоря, автоматическая генерация делает работу быстрей и эффективней чем живой человек.</p>

<p>Есть множество других способов использования <code>go generate</code> в Go. Это создание юникод-таблиц в пакете <code>unicode</code>, создание эффективных методов для кодирования и декодирования массивов в пакете <code>encoding/gob</code>, получение данных для временных зон в пакете <code>time</code> и многое другое.</p>

<p>Пожалуйста, используйте <code>go generate</code> творчески и экспериментируйте.</p>

<p>И обязательно используйте инструмент stringer для машинной генерации более эффективного кода.</p>
