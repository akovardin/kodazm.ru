+++
date = "2017-01-30T14:29:02+03:00"
draft = false
title = "Логистическая регрессия"

+++

<p>Перевод статьи "<a href="https://zupzup.org/ml-in-go-logreg/">Basic Logistic Regression with Go</a>".</p>

<p>Последние несколько лет довольно много внимания уделяется машинному обучению в самых различных его проявлениях. Так уж случилось, я потратил некоторое время на изучение ML(Machine Learning) во время подготовки к диплому и после окончания вуза.</p>

<p>Как оказалось, дорога от простой заинтересованности и очарованности к реальному коду очень непростая. Сколько знаний необходимо накопить, чтобы перейти от теории к практике? Необходимо ли знать и понимать все эти формулы и модели? Как нужно обрабатывать входные данные? На все эти вопросы нет 100% четких ответов, все зависит от того, сколько времени у вас есть, сколько энергии вы готовы потратить на изучение материала и какие у вас конечные цели.</p>

<p>В этой статья я постараюсь опустить ответы на эти вопросы и просто покажу пример кода на Go, который решает конкретный задачи с помощью машинного обучения. Я не буду рассказывать все закулисные нюансы используемых алгоритмов. Если вам интересно изучить принципы машинного обучения более подробно(а я вам это рекомендую), то вы можете найти много всего на <a href="https://www.coursera.org/">Coursera</a>.</p>

<p>И так, давайте начнем. Мы будем использовать <em>логистическую регрессию</em> для создания модели, которая поможет нам решить <em>проблему классификации</em>.</p>

<p>Проблема классификации, простым языком, заключается в определении на основании уже имеющихся наблюдений(данных) к какой категории подходит(лучше всего) следующее наблюдение. Например, можно представить, что мы рассматриваем родинки или родимые пятна в попытке классифицировать их как злокачественные или доброкачественные. Мы можем использовать изображения родинок и родимых пятен, которые мы видели в прошлом и про которые знаем, какие из них доброкачественные, а какие злокачественные для обучения нашей модели. После обучения наша модель сможет предсказывать класс родинок и родимых пятен.</p>

<p>Логистическая регрессия - это алгоритм который позволит нам создать эту самую модель. На википедии есть описание самого алгоритма, кроме того, я уверен что существует еще целая куча материала по этому алгоритму и его применению. А нам пока достаточно того, что этот алгоритм как нельзя лучше подходит для решения задач классификации. Чуть позже мы разберемся с некоторыми аспектами этого алгоритма, так как нам необходимо задать корректные параметры для его работы. Но пока нам достаточно знать что это инструмент для решения нашей задачи и он уже реализован в используемой нами библиотеке.</p>

<p>Наша основная задаче не в том, чтобы полностью разобраться как работает алгоритм логистической регрессии. Мы рассмотрим все основные шаги для решения определенной проблемы с помощью машинного обучения. И, к сожалению, мы не будем работать с по настоящему <em>большими данными</em>. У нас будет всего около сотни записей, чего конечно не достаточно для очень точного предсказания результатов в нашем небольшом примере. Тем не менее, при работе с реальными данными и реальными проблемами все методологии и шаги будут точно такими же.</p>

<p>Мы будем использовать Go, хоть это не самый распространенный в этой области язык. Тут передовые позицию удерживает R, Matlab, python и еще парочка неплохих языков. Часто Go используют в связке с этими языками для пред и пост обработки данных.</p>

<p>Тем не менее, есть несколько библиотек на Go для машинного обучения, хотя они не такие зрелые и совершенные как, например, <a href="http://scikit-learn.org/">scikit-learn</a>, но их вполне достаточно для нашего примера. Я использовал <a href="https://github.com/cdipaolo/goml">goml</a> и пробовал работать с <a href="https://github.com/sjwhitworth/golearn/">golearn</a>, который выглядит очень многообещающе.</p>

<p>В goml хорошо структурированное API и нормальная <a href="https://godoc.org/github.com/cdipaolo/goml">документация</a>.</p>

<p>Думаю, теперь мы можем начать.Все исходники и данные к этой статье есть на <a href="https://github.com/zupzup/ml-in-go-examples">github</a>.</p>

<h3>Данные</h3>

<p>Прежде всего нам нужны данные. В нашем эксперименте мы будем использовать простой набор данных в csv формате:</p>

<pre><code>exam1Score;exam2Score;accepted
45.3;38.2;1
99.1;88.1;0
...
</code></pre>

<p>В этих данных представлены результаты тестирования студентов за два экзамена и указано поступили ли они в институт по результатам экзаменов. Это очень простой пример без каких либо заморочек. На самом деле, в реальных проектах обработка данных и их анализ занимают большую часть работы и являются одной их самых важных частей.</p>

<p>Если мы будем тестировать нашу модель на тех же результатах, 
которые использовались для обучения, то результаты будут отличными, но совершенно не отражающими реальную действительность. По этой причине мы разделим все наши данные, часть будем использовать для тренировки, приблизительно 70%, а остальные 30% для проверки нашей модели.</p>

<p>При работы с реальными и большими наборами данных, мы могли бы рандомизировано сделать несколько выборок для тренировки, но это не очень целесообразно когда у вас набор данных всего из 100 строчек. Мы просто руками разделим все наши данные на два набора и сохраним их в разные файлы:</p>

<pre><code>xTrain, yTrain, err := base.LoadDataFromCSV("./data/studentsTrain.csv")
if err != nil {
    return err
}
xTest, yTest, err := base.LoadDataFromCSV("./data/studentsTest.csv")
if err != nil {
    return err
}
</code></pre>

<p>Как правило, данные нужно обрабатывать перед использованием, удалять невалидные значения, нормализовать данные, но в нашем примере данные уже нормализированны, почищены и  готовы к использованию.</p>

<p>Для визуализации данных построим график распределения. Мы будем использовать библиотеку <a href="https://github.com/gonum/plot">gonum</a> для работы с графиками.</p>

<pre><code>func plotData(xTest [][]float64, yTest []float64) error {
    p, err := plot.New()
    if err != nil {
        return err
    }
    p.Title.Text = "Exam Results"
    p.X.Label.Text = "X"
    p.Y.Label.Text = "Y"
    p.X.Max = 120
    p.Y.Max = 120

    positives := make(plotter.XYs, len(yTest))
    negatives := make(plotter.XYs, len(yTest))
    for i := range xTest {
        if yTest[i] == 1.0 {
            positives[i].X = xTest[i][0]
                positives[i].Y = xTest[i][1]
        }
        if yTest[i] == 0.0 {
            negatives[i].X = xTest[i][0]
                negatives[i].Y = xTest[i][1]
        }
    }

    err = plotutil.AddScatters(p, "Negatives", negatives, "Positives", positives)
    if err != nil {
        return err
    }
    if err := p.Save(10*vg.Inch, 10*vg.Inch, "exams.png"); err != nil {
        return err
    }
    return nil
}
</code></pre>

<p>По оси X у нас значения первого экзамена, а по оси Y значения второго. При этом точки различаются цветами в зависимости от того поступил ученик или нет(Negatives и Positives). Теперь можно посмотреть как распределены результаты экзаменов.</p>

<p>У вас получится такая картинка:</p>

<p><img src="https://zupzup.org/ml-in-go-logreg/images/exams_thmb.png" alt="" /></p>

<h3>Модель</h3>

<p>Обучение модели, в нашем случае, это проходит очень просто. Так как мы используем пакет goml, то нам достаточно вызвать метод <code>linear.NewLogistic</code>, который принимает набор определенных параметров:</p>

<ul>
<li>Алгоритм оптимизации(используем <code>base.BatchGA</code>).

<ul>
<li>В gml есть два алгоритма оптимизации для логистической регрессии. Это стохастическое градиентное восхождение и дозированный градиентный спуск. Оба алгоритма, в принципе, основаны на алгоритме инвертированного градиентного спуска. Все это нужно для максимальной подгонки модели под наши обучающие данные и уменьшение ошибки(дистанции)</li>
</ul></li>
<li>Шаг обучения и максимальное количество итераций(0.00001 и 1000)

<ul>
<li>Эти два параметра нужны для настройки градиентного спуска. Они определяют каким может быть минимальный шаг алгоритма и максимальное количество шагов необходимое для схождения алгоритма. Если мы укажем шаг обучения слишком большим, то мы никогда не окажемся рядом с минимумом, поэтому будем использовать маленькие шаги(хотя это влияет на производительность, так как нам понадобится больше шагов).</li>
</ul></li>
<li>Регуляризация

<ul>
<li>Этот параметр используется для предотвращения переобучения модели(обучение слишком близко к тестовым данным), но в нашем примере мы можем просто проигнорировать этот параметр.</li>
</ul></li>
<li>Входные данные (xTrain - оценки по экзаменам)</li>
<li>Значение класса (yTrain - результаты поступления, значения 0 или 1)</li>
</ul>

<p>В будущем можно будет поиграться с этими параметрами чтобы добиться наилучших результатов, а пока обучим нашу модель без лишних заморочек:</p>

<pre><code>model := linear.NewLogistic(base.BatchGA, 0.00001, 0, 1000, xTrain, yTrain)
err := model.Learn()
if err != nil {
    return nil, nil, err
}
</code></pre>

<p>Собственно, это все что нужно для обучения модели. Довольно просто. Теперь мы можем использовать эту модель для классификации всех новых данных. Для этого нужно использовать метод <code>model.Predict(input []float)</code>. Чтобы было понятно как это работает, представьте что мы обучили нашу модель определять где на картинке кошка, а где нет. С помощью метода <code>Predict</code> мы можем проверить новую картинку и узнать есть ли на ней кошка(с некоторой вероятностью).</p>

<p>Кроме того, метод <code>Predict</code> можно использовать для оценки точности нашей модели на тестовом наборе. Для этого создадим матрицу неточностей(Confusion Matrix). Для этого нам понадобится структура такого вида:</p>

<pre><code>// ConfusionMatrix describes a confusion matrix
type ConfusionMatrix struct {
    positive      int
    negative      int
    truePositive  int
    trueNegative  int
    falsePositive int
    falseNegative int
    accuracy      float64
}
</code></pre>

<p>Матрица неточностей - это по сути матрица ошибок. Она может использоваться для оценки нашей модели, насколько точно алгоритм справляется с классификацией данных. Для этого нам нужно сохранить некоторые значения в процессе выполнения алгоритма.</p>

<ul>
<li>positive - количество позитивных результатов(удачное поступление).</li>
<li>negative - количество негативных результатов(отказано в поступлении).</li>
<li>truePositive - количество правильно предсказанных позитивных результатов.</li>
<li>trueNegative - количество правильно предсказанных негативных результатов.</li>
<li>falsePositive - количество неправильно предсказанных позитивных результатов.</li>
<li>falseNegative - количество неправильно предсказанных негативных результатов.</li>
<li>accuracy - рассчитанная точность для нашей модели, определяется как (truePositive + trueNegative) / (positive + negative)</li>
</ul>

<p>Существует целый ряд парамеров и способов, которые позволяют оценить результативность модели, например F1 тест, но в нашем случае, будет достаточно оценить только точность.</p>

<p>Для начала начнем с подсчета позитивных и негативных результатов в нашем тестовом наборе:</p>

<pre><code>cm := ConfusionMatrix{}
for _, y := range yTest {
    if y == 1.0 {
        cm.positive++
    }
    if y == 0.0 {
        cm.negative++
    }
}
</code></pre>

<p>Теперь мы пройдемся по всем тестовым данным и запишем все случаи, когда у нас обнаруживается несоответствие между предсказанным значением и реальным результатом.</p>

<p>Небольшое замечание по переменной <code>decisionBoundary</code>. Метод <code>Predict()</code> возвращает значение вероятности в диапазоне от 0 до 1. А это значит, что нам нужно определится какие значения считать позитивным предсказанием, а какие негативным. Для начала будем использовать значения, в которых вероятность выше 50% для определения позитивных результатов, а потом посмотрим как это можно улучшить.</p>

<pre><code>// Evaluate the Model on the Test data
for i := range xTest {
    prediction, err := model.Predict(xTest[i])
    if err != nil {
        return nil, nil, err
    }
    y := int(yTest[i])
    positive := prediction[0] &gt;= decisionBoundary

   if y == 1 &amp;&amp; positive {
       cm.truePositive++
   }
   if y == 1 &amp;&amp; !positive {
       cm.falseNegative++
   }
   if y == 0 &amp;&amp; positive {
       cm.falsePositive++
   }
   if y == 0 &amp;&amp; !positive {
       cm.trueNegative++
   }
}

// Calculate Evaluation Metrics
cm.accuracy = (float64(cm.truePositive) + float64(cm.trueNegative)) /
    (float64(cm.positive) + float64(cm.negative))
</code></pre>

<p>Теперь проведем оценку нашей модели на тестовых данных. Нам придется немного повозится с подгонкой параметров модели, чтобы получить необходимую точность. На практике поиск наилучших параметров можно автоматизировать и довольно легко распараллелить.</p>

<p>Базовая реализация подбора удовлетворяющих параметров(без параллелизма и дополнительных усложнений) будет выглядеть так:</p>

<pre><code>var maxAccuracy float64
var maxAccuracyCM *ConfusionMatrix
var maxAccuracyDb float64
var maxAccuracyModel *linear.Logistic

//Try different parameters to get the best model
for db := 0.05; db &lt; 1.0; db += 0.01 {
    // Learn Model and Calculate ConfusionMatrix for given values
    cm, model, err := tryValues(0.0001, 0.0, 1000, db, xTrain, xTest, yTrain, yTest)
    if err != nil {
        return err
    }
    if cm.accuracy &gt; maxAccuracy {
        maxAccuracy = cm.accuracy
        maxAccuracyCM = cm
        maxAccuracyDb = db
        maxAccuracyModel = model
    }
}

fmt.Printf("Maximum accuracy: %.2f\n\n", maxAccuracy)
fmt.Printf("with Model: %s\n\n", maxAccuracyModel)
fmt.Printf("with Confusion Matrix:\n%s\n\n", maxAccuracyCM)
fmt.Printf("with Decision Boundary: %.2f\n", maxAccuracyDb)
fmt.Printf("with Num Iterations: %d\n", maxAccuracyIter)
</code></pre>

<p>То же самое можно проделать со всеми параметрами модели, пока мы не начнем получать удовлетворяющие результаты. Конечно, брутфорс это не единственный способ улучшения модели. В мире машинного обучения существует множество различных подходов.</p>

<p>Тем не менее, у нас получилось добиться необходимых результатов. Пример вывода нашей программы:</p>

<pre><code>Running Logistic Regression...
Maximum accuracy: 0.91

with Model: h(θ,x) = 1 / (1 + exp(-θx))
θx = -1.286 + 0.04981(x[1]) + 0.01461(x[2])

with Confusion Matrix:
Positives: 24
Negatives: 11
True Positives: 23
True Negatives: 9
False Positives: 2
False Negatives: 1

Recall: 0.96
Precision: 0.92
Accuracy: 0.91


with Decision Boundary: 0.91
with Num Iterations: 2600
</code></pre>

<h3>Заключение</h3>

<p>В этой статье мы затронули только самые поверхностные моменты машинного обучения и языка Go. Но мы поигрались с параметрами модели и посмотрели как меняются результаты в зависимости от разных настроек. Вы можете попробовать использовать этот код как шаблон для других наборов данных.</p>

<p>Сейчас машинное обучение набирает обороты. Со временем потребность в нем будет расти. Так что изучение фундаментальных основ машинного обучения и погружение в эту тему никогда не помешает. Кроме того, это очень интересная тема, которая не оставит вас равнодушным.</p>

<p>Как было сказано выше, Go не самый удачный выбор для машинного обучения(пока?). Будет ли Go использоваться для машинного обучения более плотно покажет время. Но я уверен, что это вполне возможно.</p>

<p>Почитать:</p>

<ul>
<li><a href="https://github.com/zupzup/ml-in-go-examples/blob/master/logisticregression/logisticregression.go">весь пример кода на github</a></li>
<li><a href="https://github.com/cdipaolo/goml">goml</a></li>
<li><a href="https://github.com/sjwhitworth/golearn/">golearn</a></li>
<li><a href="https://github.com/gonum/plot">графики с gonum</a></li>
<li><a href="http://scikit-learn.org/">scikit-learn</a></li>
<li><a href="https://www.coursera.org/learn/machine-learning/home">курсы по ML на Coursera</a></li>
<li><a href="https://en.wikipedia.org/wiki/Confusion_matrix">матрица не точностей</a></li>
<li><a href="https://en.wikipedia.org/wiki/Logistic_regression">логистическая регрессия</a></li>
<li><a href="https://en.wikipedia.org/wiki/Gradient_descent">градиентный спуск</a></li>
</ul>
