+++
date = "2015-03-22T15:59:03+03:00"
draft = false
title = "Ошибки это значения"

+++

<p>Продолжаем серию переводов статей из официального го блога.</p>

<p>На этот раз статья Роба Пайка <a href="http://blog.golang.org/errors-are-values">"Errors are values"</a></p>

<p>Очень часто, темой для обсуждения среди Go программистов, особенно среди новичков, становится процесс обработки ошибок. И, как правило, все сводится к нытью по поводу частого повторения конструкции:</p>

<pre><code class="go">if err != nil {
    return err
}
</code></pre>

<p>Недавно мы просканировали все открытые проекты, которые смогли найти, и обнаружили, что подобный кусок кода повторяется один-два раза на страницу, меньше чем может показаться с первого раза. Тем не менее, бытует мнение, что постоянно нужно писать</p>

<pre><code class="go">if err != nil
</code></pre>

<p>хотя на самом деле это не так.</p>

<p>Такое положение дел немного печалит, вводит в заблуждение, но, что самое главное, легко исправить. Почему так происходит? Вероятно, когда молодой гофер задается вопросом "Как обработать ошибку?", то он выучивает описанный выше паттерн и удовлетворяется этим. В других языках можно использовать try-catch или схожий механизм обработки ошибок. И программист думает, что если try-catch используется в его старом языке, то в Go нужно просто использовать <code>if err != nil</code>. Со временем, в программе собирается множество таких кусочков и код становится неуклюжим.</p>

<p>Таким образом(или не таким:) Go программист упускает фундаментальный момент в обработке ошибок: ошибки это значения.</p>

<p>Программы пишутся на основе значений, и зная, что ошибки тоже значения, их можно использовать в своем коде для реализации некоторой логики.</p>

<p>Конечно, общий принцип для обработки любого значения ошибки, это проверка на <code>nil</code>, но есть множество других вариантов работы с значениями ошибки. И использование этих вариантов помогут сделать вашу программу лучше, избавят ее от повторяющегося шаблонного кода, который появляется при использовании стандартных проверок.</p>

<p>Тип <a href="http://golang.org/pkg/bufio/#Scanner">Scanner</a> это простой пример из пакета <code>bufio</code>. Его метод <a href="http://golang.org/pkg/bufio/#Scanner.Scan">Scan</a> работает с вводом/выводом, что, конечно же, может привести к ошибке. Тем не менее, метод не возвращает все эти возможные ошибки. Вместо этого, он возвращает булевое значение. Существует отдельный метод, который можно вызвать после сканирования и который сообщит об ошибках. Клиентский код будет выглядеть так:</p>

<pre><code class="go">scanner := bufio.NewScanner(input)
for scanner.Scan() {
    token := scanner.Text()
    // обработка token
}
if err := scanner.Err(); err != nil {
    // обработка ошибки
}
</code></pre>

<p>Конечно, проверка на ошибки никуда не делась, но она выполняется только один раз. Вместо этого, метод <code>Scan</code> может быть определен как</p>

<pre><code class="go">func (s *Scanner) Scan() (token []byte, error)
</code></pre>

<p>и вот он может быть использован (в зависимости от того, найден ли токен)</p>

<pre><code class="go">scanner := bufio.NewScanner(input)
for {
    token, err := scanner.Scan()
    if err != nil {
        return err // или break
    }
    // обработка token
}
</code></pre>

<p>С виду оба способа похожи, но есть одно очень важное различие. В последнем примере клиент должен проверять ошибки на каждой итерации цикла, но в АПИ <code>Scanner</code> обработка ошибок абстрагирована от основного функционала АПИ, который осуществляет перебор токенов. При использовании АПИ, клиентский код выглядит более натуральным: сначала цикл завершает итерации, затем уже беспокоимся про ошибки. В этом случае, обработка ошибок не мешает потоку управления.</p>

<p>Конечно, проверка происходит, но она скрыта. Как только <code>Scan</code> обнаруживает ошибку ввода/вывода, он записывает ее и возвращает <code>false</code>. Отдельный метод <a href="http://golang.org/pkg/bufio/#Scanner.Err">Err</a> возвращает значение ошибки, когда это будет действительно необходимо клиенту. Это звучит тривиально, но это совсем не то же, что писать</p>

<pre><code class="go">if err != nil
</code></pre>

<p>везде или просить клиента проверять ошибки после каждой операции. Это программирование со значениями ошибок. Да, довольно простое, но программирование.</p>

<p>Следует подчеркнуть, что проверка ошибок при их возникновении - это критическая часть дизайна. Мы не говорим о том, как вообще избежать проверок, а о том, как делать это красиво.</p>

<p>Тема постоянных проверок на ошибку появилась, когда я присутствовал на конференции GoCon осенью 2014 года в Токио. Один из гоферов, его можно найти в твиттере по нику <a href="http://twitter.com/jxck_">@jxck_</a>, начал ныть по поводу повторяющегося кода проверок. Он показал пример, примерно такого вида:</p>

<pre><code class="go">_, err = fd.Write(p0[a:b])
if err != nil {
    return err
}
_, err = fd.Write(p1[c:d])
if err != nil {
    return err
}
_, err = fd.Write(p2[e:f])
if err != nil {
    return err
}
// и так далее
</code></pre>

<p>Это действительно очень повторяющийся код. В реальной программе, которая может быть значительно длиннее, рефакторинг будет еще сложнее, но в конкретном примере мы можем использовать вспомогательную функцию:</p>

<pre><code class="go">var err error
write := func(buf []byte) {
    if err != nil {
        return
    }
    _, err = w.Write(buf)
}
write(p0[a:b])
write(p1[c:d])
write(p2[e:f])
// и так далее
if err != nil {
    return err
}
</code></pre>

<p>Такой подход будет замечательно работать, но требует написать замыкание во всех функциях, где используется <code>Write</code>. Кроме того, не получится использовать стороннюю функцию(не замыкание), так как переменная <code>err</code> должна сохраняться между вызовами (можете попробовать написать).</p>

<p>Мы можем сделать это более красиво, обобщенно и реюзабельно используя идеи, описанные выше для метода <code>Scan</code>. Я упомянул этот способ в нашей дискуссии, но @jxck_ так и не увидел как его применить. После некоторого общения, усложненного языковым барьером, я попросил его ноутбук, чтобы объяснить ему, написав немного кода.</p>

<p>Я определил объект <code>errWriter</code>:</p>

<pre><code class="go">type errWriter struct {
    w   io.Writer
    err error
}
</code></pre>

<p>и добавил ему один метод <code>write</code>. Он не должен обязательно соответствовать стандартной сигнатуре <code>Write</code> и он в нижнем регистре, потому что нужен исключительно для демонстрации. Метод <code>write</code> вызывает метод <code>Write</code> у встроенного <code>Writer</code> и записывает первую ошибку для будущего использования:</p>

<pre><code class="go">func (ew *errWriter) write(buf []byte) {
    if ew.err != nil {
        return
    }
    _, ew.err = ew.w.Write(buf)
}
</code></pre>

<p>Как только произошла ошибка, метод <code>write</code> перестает выполнять запись, но значение ошибки сохраняется.</p>

<p>Учитывая <code>errWriter</code> и принцип работы метода <code>write</code>, код выше можно переписать как-то так:</p>

<pre><code class="go">ew := &amp;errWriter{w: fd}
ew.write(p0[a:b])
ew.write(p1[c:d])
ew.write(p2[e:f])
// and so on
if ew.err != nil {
    return ew.err
}
</code></pre>

<p>Это чище, даже чем при использовании замыкания, а также упрощает фактическую запись и понимание кода. Тут больше нет беспорядка. Программирование с ошибками как значениями(и интерфейсами) делает код красивым.</p>

<p>Вполне вероятно, что некоторая другая логика в этом модуле может быть реализована подобным способом или даже напрямую использовать <code>errWriter</code>.</p>

<p>Кроме того, раз уж мы написали <code>errWriter</code>, он может выполнять больше вспомогательной логики, особенно в менее искусственных задачах. Он может сохранять количество байтов. Запись может происходить в буфер, который потом будет передаваться атомарно. И многое другое.</p>

<p>Фактически, этот паттерн довольно часто применяется в стандартной библиотеке. Он реализован в пакетах <a href="http://golang.org/pkg/archive/zip/">archive/zip</a> и <a href="http://golang.org/pkg/net/http/">net/http</a>. Относительно нашего обсуждения, <a href="http://golang.org/pkg/bufio/">Writer из пакета bufio</a> тоже реализован согласно идеям <code>errWriter</code>. Хотя метод <code>bufio.Writer.Write</code> и возвращает ошибку, что необходимо для реализации интерфейса <a href="http://golang.org/pkg/io/#Writer">io.Writer</a>, этот метод может работать аналогично нашему методу <code>errWriter.write</code>, используя <code>Flush</code> для получения ошибок. Это значит, что наш пример можно переписать так:</p>

<pre><code class="go">b := bufio.NewWriter(fd)
b.Write(p0[a:b])
b.Write(p1[c:d])
b.Write(p2[e:f])
// и так далее
if b.Flush() != nil {
    return b.Flush()
}
</code></pre>

<p>Правда, существует одни недостаток, который может быть критичен в некоторых случаях: нет никакой возможности проверить, на сколько выполнилась задача до возникновения ошибки. Если эта информация действительно критична, нужно использовать более точечный подход. Однако, как правило, проверки все-или-ничего достаточно в большинстве случаев.</p>

<p>Мы рассмотрели только одну из возможных техник уменьшения количества кода при обработке ошибок. Помните, что использование <code>errWriter</code> или <code>bufio.Writer</code> не единственный путь упрощения обработки ошибок и он не подходит для всех-всех случаев. Ключевой момент в том, что ошибки это значения и для их обработки доступна вся мощь языка Go.</p>

<p>Используйте язык для упрощения обработки ошибок.</p>

<p>Но помните: что бы вы не делали, ошибки нужно обязательно проверять!</p>

<p>Для полноты истории, вы можете пообщаться <a href="http://twitter.com/jxck_">@jxck_</a>, посмотреть небольшое видео записанное на встрече и <a href="http://jxck.hatenablog.com/entry/golang-error-handling-lesson-by-rob-pike">зайти на его блог</a>.</p>
